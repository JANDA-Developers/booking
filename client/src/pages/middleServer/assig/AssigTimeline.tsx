import moment from "moment";
import React, {useState, useEffect} from "react";
import $ from "jquery";
import {Link} from "react-router-dom";
import "moment/locale/ko";
import {MutationFn} from "react-apollo";
import _ from "lodash";
import JDdayPicker from "../../../atoms/dayPicker/DayPicker";
import Timeline, {
  TimelineHeaders,
  SidebarHeader,
  DateHeader,
  ASSIGT_IMELINE_HEIGHT
} from "../../../atoms/timeline/Timeline";
import ErrProtecter from "../../../utils/errProtect";
import Button from "../../../atoms/button/Button";
import BookerModalWrap from "../../../components/bookerInfo/BookerModalWrap";
import {IUseDayPicker, useModal} from "../../../actions/hook";
import {
  IAssigGroup,
  IAssigItem,
  IAssigItemCrush,
  defaultItemProps
} from "./AssigTimelineWrap";
import assigGroupRendererFn from "./components/groupRenderFn";
import {IRoomType} from "../../../types/interface";
import Preloader from "../../../atoms/preloader/Preloader";
import "./AssigTimeline.scss";
import JDIcon, {IconSize} from "../../../atoms/icons/Icons";
import TooltipList, {
  ReactTooltip
} from "../../../atoms/tooltipList/TooltipList";
import {TimePerMs, PricingType, RoomGender, Gender} from "../../../types/enum";
import {
  allocateGuestToRoom,
  allocateGuestToRoomVariables,
  updateBooker,
  updateBookerVariables
} from "../../../types/api";
import itemRendererFn, {
  CLASS_LINKED,
  CLASS_MOVING,
  CLASS_DISABLE
} from "./components/itemRenderFn";
import {number} from "prop-types";
import {isEmpty, setMidNight, onCompletedMessage} from "../../../utils/utils";
import ItemMenu from "./components/itemMenu";
import CanvasMenu, {ICanvasMenuProps} from "./components/canvasMenu";
import {AssigTimeline} from "../../pages";
import MakeItemMenu from "./components/makeItemMenu";

// Temp ÎßàÌÇπÏö©Ïù¥ ÏûàÎäîÏßÄ
let MARKED = false;

interface IProps {
  houseId: string;
  defaultProps: any;
  dayPickerHook: IUseDayPicker;
  groupData: IAssigGroup[];
  loading: boolean;
  //  ÎîîÌîÑÎ¶¨ Îê†ÏàòÎèÑ
  roomTypesData: IRoomType[];
  deafultGuestsData: IAssigItem[];
  defaultTimeStart: number;
  defaultTimeEnd: number;
  allocateMu: MutationFn<allocateGuestToRoom, allocateGuestToRoomVariables>;
  updateBookerMu: MutationFn<updateBooker, updateBookerVariables>;
}

const ShowTimeline: React.SFC<IProps> = ({
  dayPickerHook,
  defaultProps,
  groupData,
  loading,
  houseId,
  deafultGuestsData,
  defaultTimeStart,
  defaultTimeEnd,
  allocateMu,
  updateBookerMu
}) => {
  // ÏûÑÏãú ÎßàÌÇπ Ï†úÍ±∞

  const [guestValue, setGuestValue] = useState(deafultGuestsData);
  const [canvasMenuProps, setCanvasMenuProps] = useState<ICanvasMenuProps>({
    start: 0,
    end: 0,
    groupId: ""
  });

  // Ìà¥ÌåÅÎì§ÏùÑ Ï†úÍ±∞ÌïòÍ≥†
  const handleWindowClickEvent = () => {
    if (MARKED) {
      setGuestValue([...guestValue.filter(item => item.type !== "mark")]);
      MARKED = false;
    }

    // üëø Ìà¥ÌåÅ Í≥µÌÜµ ÌÅ¥ÎûòÏä§Î•º ÎëêÎäîÍ≤åÏ¢ãÏùÑÎìØ
    $("#canvasTooltip, #makeTooltip").removeClass(
      "canvasTooltip--show makeTooltip--show"
    );
  };

  // Ìà¥ÌåÅ Ï†úÍ±∞ Ïù¥Î≤§Ìä∏Îì§ÏùÑ windowÏóê Îã¨ÏïÑÏ§å Í∑∏Î¶¨Í≥† ÎÇòÍ∞àÎïå Ï†úÍ±∞
  useEffect(() => {
    window.addEventListener("click", handleWindowClickEvent);
    return () => {
      window.removeEventListener("click", handleWindowClickEvent);
    };
  });

  // Ìà¥ÌåÅ Î¶¨ÎπåÎìú
  useEffect(() => {
    ReactTooltip.rebuild();
  });

  // ÏòàÏïΩÏûê ÌåùÏóÖ Î™®Îã¨
  const bookerModal = useModal(false);

  // ü¶Ñ Ïú†Ìã∏ from Í≥º to ÏÇ¨Ïù¥Ïóê ÏûàÎäî ÏòàÏïΩÎì§ÏùÑ Ï∞æÏïÑÏ§å ÏòµÏÖòÏúºÎ°ú roomId ÍπåÏßÄ ÌïÑÌÑ∞Í∞ÄÎä•
  const filterTimeZone = (
    from: number,
    to: number,
    roomId?: string
  ): IAssigItem[] => {
    if (!roomId) {
      return guestValue.filter(
        guest =>
          (guest.start >= from && guest.start < to) ||
          (guest.end > from && guest.end <= to) ||
          (guest.end === from && guest.end === to)
      );
    }
    return guestValue.filter(
      guest =>
        (guest.start >= from && guest.start < to) ||
        (guest.end > from && guest.end <= to) ||
        (guest.end === from && guest.end === to)
    );
  };

  // Ï∂©ÎèåÏãúÍ∞Ñ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Í≤åÏä§Ìä∏1Ïù¥ Ïù¥ÎèôÌïòÎäî Ï£ºÏ≤¥
  interface ICrushTime {
    crushGuest: string;
    crushGuest2: string;
    guestIndex: number;
    start: number;
    end: number;
  }
  // ü¶Ñ Ïú†Ìã∏ ÎëêÍ≤åÏä§Ìä∏Ïùò Ï∂©ÎèåÏãúÍ∞Ñ Íµ¨Ìï¥Ï§å ÏóÜÎã§Î©¥ falseÎ•º Î∞òÌôòÌï®
  const crushTime = (
    guest: IAssigItem,
    guest2: IAssigItem
  ): ICrushTime | false => {
    const minEnd = guest.end < guest2.end ? guest.end : guest2.end;
    const minStart = guest.start < guest2.start ? guest.start : guest2.start;
    if (minStart >= minEnd) return false;
    return {
      crushGuest: guest.id,
      crushGuest2: guest2.id,
      guestIndex: guest.guestIndex,
      start: minStart,
      end: minEnd
    };
  };

  // ü¶Ñ Ïú†Ìã∏ ÏÇ¨ÎûåÏù¥ Í∑∏Ïû•ÏÜåÏóê Í∑∏ÏãúÍ∞ÑÎåÄÏóê ÏûàÎã§Î©¥ Ï∂©ÎèåÏãúÍ∞ÑÏùÑ Ï£ºÍ≥† ÏïÑÎãàÎ©¥ falseÎ•º Ï§å
  const isTherePerson = (
    startTime: number,
    endTime: number,
    groupId: string,
    guest: IAssigItem
  ) => {
    const atTimeGuests = filterTimeZone(startTime, endTime);
    const atTimePlaceGuests = atTimeGuests.filter(
      inGuest => inGuest.group === groupId
    );
    // ÏûêÍ∏∞ÏûêÏã†Ïù¥ Ìè¨Ìï®Îê®ÎãàÎã§..
    if (atTimePlaceGuests.length > 1) {
      const crushTimes = atTimePlaceGuests.map(inGuest =>
        crushTime(inGuest, guest)
      );
      if (!isEmpty(crushTimes)) return crushTimes;
    }
    return false;
  };

  // ü¶Ñ Ïú†Ìã∏ ÏÑ±Î≥ÑÏù¥ ÎßûÎäîÏßÄ Í≤ÄÏÇ¨ÌïòÍ≥† Í≤∞Í≥ºÍ∞Ä ÎßûÏßÄÏïäÎã§Î©¥ CrushTimeÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
  const isGenderSafe = (
    targetGroup: IAssigGroup,
    item: IAssigItem,
    start: number,
    end: number
  ): boolean | ICrushTime[] => {
    // ÏÑ±Î≥ÑÍ≤ÄÏÇ¨
    if (targetGroup.roomType.roomGender === RoomGender.ANY) {
      return true;
    }
    if (targetGroup.roomType.roomGender === RoomGender.MALE) {
      return item.gender === Gender.MALE;
    }
    if (targetGroup.roomType.roomGender === RoomGender.FEMALE) {
      return item.gender === Gender.FEMALE;
    }
    if (targetGroup.roomType.roomGender === RoomGender.SEPARATELY) {
      const atTimeRoomGuests = filterTimeZone(start, end, targetGroup.roomId);
      const crushGendersGuests = atTimeRoomGuests.filter(
        guest => guest.gender !== item.gender
      );
      return crushGendersGuests
        .map(guest => crushTime(item, guest))
        .filter(crushTime => crushTime)
        .map(
          (crushTime): ICrushTime => {
            if (!crushTime) {
              throw new Error("ÎÄ®");
            }
            return crushTime;
          }
        );
    }
    return true;
  };

  const handleItemDoubleClick = (itemId: any, e: any, time: any) => {
    const target = guestValue.find(guest => guest.id === itemId);
    if (!target) return;
    if (target.type === "block") return;
    if (target.type === "normal")
      bookerModal.openModal({bookerId: target.bookerId});
    if (target.type === "make")
      $("#makeTooltip")
        .css("left", e.clientX)
        .css("top", e.clientY)
        .addClass("makeTooltip--show");
  };

  // ÏãúÍ∞ÑÏùÑ Î∞õÏïÑÏÑú Í≤åÏä§Ìä∏Îì§Ï§ë Í∑∏ÏãúÍ∞ÑÎåÄÏóê ÏûàÎäî Í≤åÏä§Ìä∏Îì§ÏùÑ Î∞òÌôòÌï®
  // Room Id ÏÑ†ÌÉùÏ†Å Î≤®Î¶¨Îç∞Ïù¥ÏÖò

  //  Í≤åÏä§Ìä∏Í∞Ä Í∑∏ ÏãúÍ∞ÑÎåÄÏóê Í∑∏ Í∑∏Î£πÏóê Í¥∫Ï∞ÆÏùÄÏßÄ Í≤ÄÏÇ¨Ìï® Í≤ÄÏÇ¨Ìïú Í≤∞Í≥ºÎ•º Ï¶âÍ∞ÅÎ∞òÏòÅ.
  const oneGuestValidation = (
    guest: IAssigItem,
    start: number,
    end: number,
    groupId: string
  ) => {
    const tempGuest: IAssigItem = {
      ...guest,
      start,
      end,
      group: groupId
    };
    let validater: IAssigItemCrush[] = [];

    const isTherePersonResult = isTherePerson(start, end, groupId, tempGuest);
    // ÏûêÎ¶¨Ï∂©Îèå Î∞úÏÉù
    if (isTherePersonResult) {
      const temp: any = isTherePersonResult.filter(inCrushTime => inCrushTime);
      const crushTimes: ICrushTime[] = temp;

      const validate = crushTimes.map(inCrushTime => ({
        guestIndex: inCrushTime.guestIndex,
        reason: "ÏûêÎ¶¨Ï∂©Îèå",
        start: inCrushTime.start,
        end: inCrushTime.end
      }));

      validater = [...validater, ...validate];
    }

    const targetGroup = groupData.find(group => group.id === groupId);
    if (!targetGroup) return;
    const isGenderSafeResult = isGenderSafe(targetGroup, tempGuest, start, end);

    // ÏÑ±Î≥ÑÏ∂©Îèå Î∞úÏÉù
    if (isGenderSafeResult !== true) {
      if (isGenderSafeResult === false) {
        const validate = {
          guestIndex: guest.guestIndex,
          reason: "ÏÑ±Î≥ÑÎ¨∏Ï†ú",
          start,
          end
        };
        validater.push(validate);
      } else {
        const temp: any = isGenderSafeResult.filter(inCrushTime => inCrushTime);
        const crushTimes: ICrushTime[] = temp;
        const validate = crushTimes.map(inCrushTime => ({
          guestIndex: guest.guestIndex,
          reason: "ÏûêÎ¶¨Ï∂©Îèå",
          start: inCrushTime.start,
          end: inCrushTime.end
        }));
        validater = [...validater, ...validate];
      }
    }

    if (guestValue[guest.guestIndex]) {
      guestValue[guest.guestIndex].validate = validater;
    }
    setGuestValue([...guestValue]);
  };

  //  Ï∫îÎ≤ÑÏä§Ïóê Î∏îÎü≠ Ï∂îÍ∞Ä
  const addBlock = (time: number, groupId: string) => {
    guestValue.push({
      ...defaultItemProps,
      type: "block",
      id: `block${time}${groupId}`,
      start: time,
      end: time + TimePerMs.DAY,
      group: groupId
    });
    setGuestValue([...guestValue]);
  };

  //  Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠Ïãú Ìò∏Ï∂úÎê®
  const handleCanvasClick = (
    groupId: string,
    time: number,
    e: React.MouseEvent<HTMLElement>
  ) => {
    if (e.ctrlKey) {
      addBlock(time, groupId);
    }
    $(".assigItem").removeClass(CLASS_LINKED);
  };

  // Î¶¨ÏÇ¨Ïù¥Ï¶à ÎêòÏóàÏùÑÎïå Î≤®Î¶¨Îç∞Ïù¥ÏÖò Ìï¥Ï§çÎãàÎã§.
  const resizeValidater = (item: IAssigItem, time: number) => {
    const linkedGuests = guestValue.filter(
      guest => guest.bookerId === item.bookerId
    );

    linkedGuests.forEach(guest => {
      if (guest.bookerId === item.bookerId)
        oneGuestValidation(guest, guest.start, time, guest.group);
    });
  };

  // ÏïÑÏù¥ÌÖúÏù¥ Í∑∏Î£πÏóê Í∑∏ÏãúÍ∞ÑÎåÄÏóê Ìè¨Ìï®Îê†Ïàò ÏûàÎäîÏßÄ Í≤ÄÏÇ¨Ìï¥Ï§çÎãàÎã§.
  // const moveValidater = (item: IAssigItem, targetGroup: IAssigGroup, time: number): IValidationResult[] => {
  //   const linkedGuests = guestValue.filter(guest => guest.bookerId === item.bookerId);
  //   // Ï¢åÏö∞MOVE ÏùºÍ≤ΩÏö∞
  //   if (Math.abs(time - item.start) >= TimePerMs.DAY) {
  //     const validaterResults = linkedGuests.map((guest) => {
  //       const result = validater(guest);
  //       return result;
  //     });
  //     return validaterResults;
  //   }
  //   // ÏúÑÏïÑÎûò MOVE
  //   const validaterResult = validater(item);
  //   return [validaterResult];
  // };
  // Handle -- item : TripleClick

  // Ï∫îÎ≤ÑÏä§ ÎçîÎ∏îÌÅ¥Î¶≠Ïãú
  const handleCanvasDoubleClick = (
    groupId: string,
    time: number,
    e: React.MouseEvent<HTMLElement>
  ) => {
    e.persist();
    e.preventDefault();
    e.stopPropagation();
    MARKED = true;

    $("#canvasTooltip")
      .css("left", e.clientX)
      .css("top", e.clientY)
      .addClass("canvasTooltip--show");

    setCanvasMenuProps({
      start: time,
      end: time + TimePerMs.DAY,
      groupId: groupId
    });

    const filteredGuestValue = guestValue.filter(
      guest => guest.type !== "mark"
    );
    filteredGuestValue.push({
      ...defaultItemProps,
      id: `mark${groupId}${time}`,
      type: "mark",
      start: time,
      end: time + TimePerMs.DAY,
      group: groupId
    });

    setGuestValue([...filteredGuestValue]);
  };

  // Í∞ôÏùÄ ÏòàÏïΩÏûêÍ∞Ä ÏòàÏïΩÌïú Í≤åÏä§Ìä∏Îì§ÏùÑ ÌïúÎ≤àÏóê Î≥ÄÍ≤Ω
  const resizeLinkedItems = (bookerId: string, newTime: number) => {
    // TODO Ïó¨Í∏∞ÏÑú StateÎ•ºÌÜµÌïòÏó¨ Ï°∞ÏûëÌï†Ïàò ÏûàÎèÑÎ°ùÌïòÏûê
    guestValue.forEach(guest => {
      const inGuest = guest;
      if (guest.bookerId === bookerId) inGuest.end = newTime;
    });
    setGuestValue([...guestValue]);
  };

  // Í∞ôÏùÄ ÏòàÏïΩÏûêÍ∞Ä ÏòàÏïΩÌïú Í≤åÏä§Ìä∏Îì§ÏùÑ ÌïúÎ≤àÏóê Ïù¥Îèô
  const moveLinkedItems = (bookerId: string, newTime: number) => {
    guestValue.forEach(guest => {
      const inGuest = guest;
      if (guest.bookerId === bookerId) {
        inGuest.end += newTime - guest.start;
        inGuest.start = newTime;
      }
    });
    setGuestValue([...guestValue]);
  };

  // ü¶Ñ Ïú†Ìã∏ Í≤åÏä§Ìä∏Î•º ÌôîÎ©¥ÏóêÏÑú ÏÇ≠Ï†ú
  const clearItem = (id: string) => {
    setGuestValue([...guestValue.filter(guest => guest.id !== id)]);
  };

  // üê≠ ÎßàÏö∞Ïä§ ÏõÄÏßÅÏù¥Î©¥ Ìò∏Ï∂úÎê®
  // ÏÉàÎ°úÏö¥ ÏãúÍ∞ÑÏùÑ Î¶¨ÌÑ¥ÌïòÍ±∞ÎÇò timeÏùÑ Î¶¨ÌÑ¥ÌïòÏÑ∏Ïöî.
  const handleMoveResizeValidator = (
    action: "move" | "resize",
    item: IAssigItem,
    time: number,
    resizeEdge: "left" | "right" | undefined
  ): number => {
    if (action === "resize") {
      // ÏµúÏÜå ÏïÑÏù¥ÌÖúÏ§å ÏÑ§Ï†ï
      if (item.start >= time) return item.end;
      if (setMidNight(new Date().getTime()) >= time) return item.end;

      resizeValidater(item, time);
      resizeLinkedItems(item.bookerId, time);
    }

    if (action === "move") {
      $(`.assigItem--booker${item.bookerId}`).addClass(CLASS_MOVING);
      $(`#assigItem--guest${item.id}`).removeClass(CLASS_MOVING);

      const targetGroup = groupData.find(group => group.id === item.group);
      // Ïù¥ÎèôÌïòÎäîÍ≥≥ ÏÑ±Î≥Ñ Ï†úÌïú ÌôïÏù∏
      if (targetGroup) {
        // üíîüíîüíîüíî ÏïÑÏù¥ÌÖúÏù¥ Í∏∞Ï°¥ ÏïÑÏù¥ÌÖúÍ≥º ÎèôÏùºÌïú ÏÉÅÌÉúÎùºÏÑú groupÏù¥ New Í∑∏Î£πÏù¥ ÏïÑÎãôÎãàÎã§ „Ö†„Ö†„Ö†
      }
      moveLinkedItems(item.bookerId, time);
    }

    return time;
  };
  // üê≠ÎßàÏö∞Ïä§ ÎÜìÏïÑÏïº Ìò∏Ï∂úÎê®.
  const handleItemMove = async (
    itemId: string,
    dragTime: number,
    newGroupOrder: number
  ) => {
    const guestValueOriginCopy = guestValue.slice();
    const guestValueCopy = guestValue.slice();
    const targetGuestIndex = guestValue.findIndex(guest => guest.id === itemId);
    guestValueCopy[targetGuestIndex] = {
      ...guestValueCopy[targetGuestIndex],
      group: groupData[newGroupOrder].id
    };
    setGuestValue([...guestValueCopy]);

    const newGroupId = groupData[newGroupOrder].roomId;

    $(`.${CLASS_MOVING}`).removeClass(CLASS_MOVING);

    // Î∞∞Ï†ï ÎÆ§ÌÖåÏù¥ÏÖòÏùÑ Î∞úÏÉù
    const result = await allocateMu({
      variables: {
        guestId: itemId,
        roomId: newGroupId,
        bedIndex: groupData[newGroupOrder].bedIndex
      }
    });

    // Ïã§Ìå®ÌïòÎ©¥ Ï†ÑÎ∂Ä ÎêòÎèåÎ¶º
    if (result && result.data && !result.data.AllocateGuestToRoom.ok) {
      setGuestValue([...guestValueOriginCopy]);
    }
  };

  // üê≠ ÎßàÏö∞Ïä§ ÎÜìÏïÑÏïº Ìò∏Ï∂úÎê®
  const handleItemResize = (
    itemId: string,
    time: number,
    edge: "left" | "right"
  ) => {};

  // üê≠ ÏïÑÏù¥ÌÖú ÌÅ¥Î¶≠
  const hanldeItemClick = async (
    itemId: string,
    e: React.MouseEvent<HTMLElement>,
    time: number
  ) => {
    const target = guestValue.find(guest => guest.id === itemId);

    if (!target) return;
    if (target.bookerId === "block") return;

    // Ïª®Ìä∏Î°§: Ï≤¥ÌÅ¨Ïù∏
    if (e.ctrlKey) {
      const result = await updateBookerMu({
        variables: {
          bookerId: target.bookerId,
          params: {
            isCheckIn: !guestValue[target.guestIndex].isCheckin
          }
        }
      });

      // ÏïÑÌè¥Î°ú ÌÜµÏã† ÏÑ±Í≥µ
      if (result && result.data) {
        onCompletedMessage(result.data.UpdateBooker, "Ï≤¥ÌÅ¨Ïù∏", "Ïã§Ìå®");
        if (result.data.UpdateBooker.ok) {
          // ÎÆ§ÌÖåÏù¥ÏÖò ÏÑ±Í≥µÏãú
          guestValue[target.guestIndex].isCheckin = !guestValue[
            target.guestIndex
          ].isCheckin;
          setGuestValue([...guestValue]);
        } else {
          // ÎÆ§ÌÖåÏù¥ÏÖò Ïã§Ìå®Ïãú
        }
      }
    }
    // Ïâ¨ÌîÑÌä∏ ÌåùÏóÖ
    if (e.shiftKey) {
      bookerModal.openModal({bookerId: target.bookerId});
    }
    // ÏïåÌä∏: Î∞∞Ï†ïÌôïÏ†ï
    if (e.altKey) {
      guestValue[target.guestIndex].isUnsettled = !guestValue[target.guestIndex]
        .isUnsettled;
      setGuestValue([...guestValue]);
    }
  };

  // üê≠ Ï∫îÎ≤ÑÏä§ Ïò§Î•∏Ï™Ω ÌÅ¥Î¶≠
  const handleCanvasContextMenu = (
    groupId: string,
    time: number,
    e: React.MouseEvent<HTMLElement>
  ) => {};

  // üê≠ ÏïÑÏù¥ÌÖúÏù¥ ÏÑ†ÌÉùÎêòÏóàÏùÑÎïå
  const handleItemSelect = async (
    itemId: string,
    e: React.MouseEvent<HTMLElement>,
    time: number
  ) => {
    const target = guestValue.find(guest => guest.id === itemId);
    if (target) {
      await $(".assigItem").removeClass(CLASS_LINKED);
      $(`.assigItem--booker${target.bookerId}`).addClass(CLASS_LINKED);
    }
  };
  // ÏãúÍ∞ÑÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏùÑÎñÑ
  const handleTimeChange = (
    visibleTimeStart: number,
    visibleTimeEnd: number,
    updateScrollCanvas: any
  ) => {
    updateScrollCanvas(visibleTimeStart, visibleTimeEnd);
  };

  return (
    <div id="AssigTimeline" className="assigTimeline container container--full">
      <div className="docs-section">
        <h3>
          {"Î∞©Î∞∞Ï†ï"}
          {loading && <Preloader />}
        </h3>
        <div className="flex-grid flex-grid--end">
          <Link to="/middleServer/timelineConfig">
            <Button float="right" icon="roomChange" label="Î∞©Íµ¨Ï°∞ Î≥ÄÍ≤Ω" />
          </Link>
        </div>
        <CanvasMenu
          addBlock={addBlock}
          canvasMenuProps={canvasMenuProps}
          guestValue={guestValue}
          setGuestValue={setGuestValue}
        />
        <MakeItemMenu
          groupData={groupData}
          guestValue={guestValue}
          bookerModalHook={bookerModal}
        />
        <ItemMenu />
        <Timeline
          onItemMove={handleItemMove}
          onItemResize={handleItemResize}
          items={guestValue}
          groups={groupData}
          {...defaultProps}
          onItemDoubleClick={handleItemDoubleClick}
          onItemClick={hanldeItemClick}
          onCanvasDoubleClick={handleCanvasDoubleClick}
          onCanvasClick={handleCanvasClick}
          onTimeChange={handleTimeChange}
          itemRenderer={(props: any) => itemRendererFn({...props, clearItem})}
          groupRenderer={assigGroupRendererFn}
          defaultTimeEnd={defaultTimeEnd}
          defaultTimeStart={defaultTimeStart}
          moveResizeValidator={handleMoveResizeValidator}
          onItemSelect={handleItemSelect}
          onCanvasContextMenu={handleCanvasContextMenu}
        >
          <TimelineHeaders>
            <SidebarHeader>
              {({getRootProps}: any) => (
                <div className="rct-header-root__topLeft" {...getRootProps()}>
                  <JDdayPicker
                    isRange={false}
                    input
                    canSelectBeforeDays={false}
                    label="Îã¨Î†•ÎÇ†Ïûê"
                    {...dayPickerHook}
                    className="JDwaves-effect JDoverflow-visible"
                    inputComponent={
                      <span>
                        <JDIcon
                          className="specificPrice__topLeftIcon"
                          size={IconSize.MEDEIUM_SMALL}
                          icon="calendar"
                        />
                      </span>
                    }
                  />
                </div>
              )}
            </SidebarHeader>
            <DateHeader height={34} unit="day" />
            <DateHeader />
          </TimelineHeaders>
        </Timeline>
        {groupData.length === 0 && (
          <div className="assigTimeline__placeHolderWrap">
            <Link to="/middleServer/timelineConfig">
              <JDIcon
                className="assigTimeline__placeHolder"
                size={IconSize.LARGE}
                icon="addCircle"
              />
            </Link>
          </div>
        )}
      </div>
      <BookerModalWrap houseId={houseId} modalHook={bookerModal} />
    </div>
  );
};

export default ErrProtecter(ShowTimeline);
