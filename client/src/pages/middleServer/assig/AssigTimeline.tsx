import moment from 'moment-timezone';
import React, { useState, useEffect } from 'react';
import $ from 'jquery';
import { Link } from 'react-router-dom';
import 'moment/locale/ko';
import { MutationFn } from 'react-apollo';
import _ from 'lodash';
import JDdayPicker from '../../../atoms/dayPicker/DayPicker';
import Timeline, {
  TimelineHeaders,
  SidebarHeader,
  DateHeader,
  ASSIGT_IMELINE_HEIGHT,
} from '../../../atoms/timeline/Timeline';
import ErrProtecter from '../../../utils/errProtect';
import Button from '../../../atoms/button/Button';
import BookerModalWrap from '../../../components/bookerInfo/BookerModalWrap';
import { IUseDayPicker, useModal } from '../../../actions/hook';
import {
  IAssigGroup, IAssigItem, IAssigItemCrush, defaultItemProps,
} from './AssigTimelineWrap';
import assigGroupRendererFn from './components/groupRenderFn';
import { IRoomType } from '../../../types/interface';
import Preloader from '../../../atoms/preloader/Preloader';
import './AssigTimeline.scss';
import JDIcon, { IconSize } from '../../../atoms/icons/Icons';
import TooltipList, { ReactTooltip } from '../../../atoms/tooltipList/TooltipList';
import {
  TimePerMs, PricingType, RoomGender, Gender,
} from '../../../types/enum';
import { allocateGuestToRoom, allocateGuestToRoomVariables } from '../../../types/api';
import { CLASS_LINKED, CLASS_MOVING, CLASS_DISABLE } from './components/itemRenderFn';
import { number } from 'prop-types';
import { isEmpty, setMidNight } from '../../../utils/utils';
import ItemMenu from './components/itemMenu';
import CanvasMenu from './components/canvasMenu';

moment.tz.setDefault('Asia/Seoul');
moment.locale('kr');


// get timezone and locale from some config 

let timer: null | number = null; // timer required to reset
const timeout = 200; // timer reset in ms

interface IProps {
  defaultProps: any;
  dayPickerHook: IUseDayPicker;
  groupData: IAssigGroup[];
  loading: boolean;
  //  ÎîîÌîÑÎ¶¨ Îê†ÏàòÎèÑ
  roomTypesData: IRoomType[];
  deafultGuestsData: IAssigItem[];
  defaultTimeStart: number;
  defaultTimeEnd: number;
  allocateMu: MutationFn<allocateGuestToRoom, allocateGuestToRoomVariables>;
}

const ShowTimeline: React.SFC<IProps> = ({
  dayPickerHook,
  defaultProps,
  groupData,
  loading,
  deafultGuestsData,
  defaultTimeStart,
  defaultTimeEnd,
  allocateMu,
}) => {
  const [guestValue, setGuestValue] = useState(deafultGuestsData);
  useEffect(() => {
    ReactTooltip.rebuild();
  });

  const bookerModal = useModal(false);
  // ü¶Ñ Ïú†Ìã∏
  const filterTimeZone = (from: number, to: number, roomId?: string): IAssigItem[] => {
    if (!roomId) {
      return guestValue.filter(
        guest => (guest.start >= from && guest.start < to)
          || (guest.end > from && guest.end <= to)
          || (guest.end === from && guest.end === to),
      );
    }
    return guestValue.filter(
      guest => (guest.start >= from && guest.start < to)
        || (guest.end > from && guest.end <= to)
        || (guest.end === from && guest.end === to),
    );
  };
  interface ICrushTime {
    crushGuest: string;
    crushGuest2: string;
    guestIndex: number;
    start: number;
    end: number;
  }
  // ü¶Ñ Ïú†Ìã∏ Í≤åÏä§Ìä∏ ÎëòÏùò Ï∂©ÎèåÏãúÍ∞ÑÏùÑ Íµ¨Ìï¥Ï§å Ï∂©ÎèåÏãúÍ∞ÑÏùÑ Íµ¨Ìï¥Ï§å ÏóÜÎã§Î©¥ false
  const crushTime = (guest: IAssigItem, guest2: IAssigItem): ICrushTime | false => {
    const minEnd = guest.end < guest2.end ? guest.end : guest2.end;
    const minStart = guest.start < guest2.start ? guest.start : guest2.start;
    if (minStart >= minEnd) return false;
    return {
      crushGuest: guest.id,
      crushGuest2: guest2.id,
      guestIndex: guest.guestIndex,
      start: minStart,
      end: minEnd,
    };
  };
  // ü¶Ñ Ïú†Ìã∏ ÏÇ¨ÎûåÏù¥ Í∑∏Ïû•ÏÜåÏóê Í∑∏ÏãúÍ∞ÑÎåÄÏóê ÏûàÎã§Î©¥ Ï∂©ÎèåÏãúÍ∞ÑÏùÑ Ï£ºÍ≥† ÏïÑÎãàÎ©¥ falseÎ•º Ï§å
  const isTherePerson = (startTime: number, endTime: number, groupId: string, guest: IAssigItem) => {
    const atTimeGuests = filterTimeZone(startTime, endTime);
    const atTimePlaceGuests = atTimeGuests.filter(inGuest => inGuest.group === groupId);
    // ÏûêÍ∏∞ÏûêÏã†Ïù¥ Ìè¨Ìï®Îê®ÎãàÎã§..
    if (atTimePlaceGuests.length > 1) {
      const crushTimes = atTimePlaceGuests.map(inGuest => crushTime(inGuest, guest));
      if (!isEmpty(crushTimes)) return crushTimes;
    }
    return false;
  };

  // ü¶Ñ Ïú†Ìã∏ ÏÑ±Î≥ÑÏù¥ ÎßûÎäîÏßÄ Í≤ÄÏÇ¨ÌïòÍ≥† CrushTimeÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
  const isGenderSafe = (
    targetGroup: IAssigGroup,
    item: IAssigItem,
    start: number,
    end: number,
  ): boolean | ICrushTime[] => {
    // ÏÑ±Î≥ÑÍ≤ÄÏÇ¨
    if (targetGroup.roomType.roomGender === RoomGender.MIXED) {
      return true;
    }
    if (targetGroup.roomType.roomGender === RoomGender.MALE) {
      return item.gender === Gender.MALE;
    }
    if (targetGroup.roomType.roomGender === RoomGender.FEMALE) {
      return item.gender === Gender.FEMALE;
    }
    if (targetGroup.roomType.roomGender === RoomGender.SEPARATELY) {
      const atTimeRoomGuests = filterTimeZone(start, end, targetGroup.roomId);
      const crushGendersGuests = atTimeRoomGuests.filter(guest => guest.gender !== item.gender);
      return crushGendersGuests
        .map(guest => crushTime(item, guest))
        .filter(crushTime => crushTime)
        .map(
          (crushTime): ICrushTime => {
            if (!crushTime) {
              throw new Error('ÎÄ®');
            }
            return crushTime;
          },
        );
    }
    return true;
  };

  const handleItemDoubleClick = (itemId: any, e: any, time: any) => {
    const target = guestValue.find(guest => guest.id === itemId);
    if (!target) return;
    // ÌçºÌè¨Î®ºÏä§ Ìñ•ÏÉÅÏùÑ ÏúÑÌï¥ÏÑúÎùºÎ©¥ ID Îäî Ïù∏Îç±Ïä§Ïó¨ÏïºÌïúÎã§?
    timer = window.setTimeout(() => {
      timer = null;
    }, timeout);
    // items[itemID].key
    bookerModal.openModal({ bookerId: target.bookerId });
  };

  // ÏãúÍ∞ÑÏùÑ Î∞õÏïÑÏÑú Í≤åÏä§Ìä∏Îì§Ï§ë Í∑∏ÏãúÍ∞ÑÎåÄÏóê ÏûàÎäî Í≤åÏä§Ìä∏Îì§ÏùÑ Î∞òÌôòÌï®
  // Room Id ÏÑ†ÌÉùÏ†Å Î≤®Î¶¨Îç∞Ïù¥ÏÖò

  //  Í∑∏ Í≤åÏä§Ìä∏Í∞Ä Í∑∏ ÏãúÍ∞ÑÏóê Í∑∏ Í∑∏Î£πÏóê Í¥∫Ï∞ÆÏùÄÏßÄ Í≤ÄÏÇ¨Ìï® Í≤ÄÏÇ¨Ìïú Í≤∞Í≥ºÎ•º Ï¶âÍ∞ÅÎ∞òÏòÅ
  const oneGuestValidation = (guest: IAssigItem, start: number, end: number, groupId: string) => {
    const tempGuest: IAssigItem = {
      ...guest,
      start,
      end,
      group: groupId,
    };
    let validater: IAssigItemCrush[] = [];

    const isTherePersonResult = isTherePerson(start, end, groupId, tempGuest);
    // ÏûêÎ¶¨Ï∂©Îèå Î∞úÏÉù
    if (isTherePersonResult) {
      const temp: any = isTherePersonResult.filter(inCrushTime => inCrushTime);
      const crushTimes: ICrushTime[] = temp;

      const validate = crushTimes.map(inCrushTime => ({
        guestIndex: inCrushTime.guestIndex,
        reason: 'ÏûêÎ¶¨Ï∂©Îèå',
        start: inCrushTime.start,
        end: inCrushTime.end,
      }));

      validater = [...validater, ...validate];
    }

    const targetGroup = groupData.find(group => group.id === groupId);
    if (!targetGroup) return;
    const isGenderSafeResult = isGenderSafe(targetGroup, tempGuest, start, end);

    // ÏÑ±Î≥ÑÏ∂©Îèå Î∞úÏÉù
    if (isGenderSafeResult !== true) {
      if (isGenderSafeResult === false) {
        const validate = {
          guestIndex: guest.guestIndex,
          reason: 'ÏÑ±Î≥ÑÎ¨∏Ï†ú',
          start,
          end,
        };
        validater.push(validate);
      } else {
        const temp: any = isGenderSafeResult.filter(inCrushTime => inCrushTime);
        const crushTimes: ICrushTime[] = temp;
        const validate = crushTimes.map(inCrushTime => ({
          guestIndex: guest.guestIndex,
          reason: 'ÏûêÎ¶¨Ï∂©Îèå',
          start: inCrushTime.start,
          end: inCrushTime.end,
        }));
        validater = [...validater, ...validate];
      }
    }

    if (guestValue[guest.guestIndex]) {
      guestValue[guest.guestIndex].validate = validater;
    }
    setGuestValue([...guestValue]);
  };

  //  Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠Ïãú Ìò∏Ï∂úÎê®
  const handleCanvasClick = (groupId: string, time: number, e: React.MouseEvent<HTMLElement>) => {
    if (e.ctrlKey) {
      guestValue.push({
        ...defaultItemProps,
        type: 'block',
        id: `block${time}${groupId}`,
      });
      setGuestValue([...guestValue]);
    }
    $('.assigItem').removeClass(CLASS_LINKED);
  };

  // Î¶¨ÏÇ¨Ïù¥Ï¶à ÎêòÏóàÏùÑÎïå Î≤®Î¶¨Îç∞Ïù¥ÏÖò Ìï¥Ï§çÎãàÎã§.
  const resizeValidater = (item: IAssigItem, time: number) => {
    const linkedGuests = guestValue.filter(guest => guest.bookerId === item.bookerId);

    linkedGuests.forEach((guest) => {
      if (guest.bookerId === item.bookerId) oneGuestValidation(guest, guest.start, time, guest.group);
    });
  };

  // ÏïÑÏù¥ÌÖúÏù¥ Í∑∏Î£πÏóê Í∑∏ÏãúÍ∞ÑÎåÄÏóê Ìè¨Ìï®Îê†Ïàò ÏûàÎäîÏßÄ Í≤ÄÏÇ¨Ìï¥Ï§çÎãàÎã§.
  // const moveValidater = (item: IAssigItem, targetGroup: IAssigGroup, time: number): IValidationResult[] => {
  //   const linkedGuests = guestValue.filter(guest => guest.bookerId === item.bookerId);
  //   // Ï¢åÏö∞MOVE ÏùºÍ≤ΩÏö∞
  //   if (Math.abs(time - item.start) >= TimePerMs.DAY) {
  //     const validaterResults = linkedGuests.map((guest) => {
  //       const result = validater(guest);
  //       return result;
  //     });
  //     return validaterResults;
  //   }
  //   // ÏúÑÏïÑÎûò MOVE
  //   const validaterResult = validater(item);
  //   return [validaterResult];
  // };
  // Handle -- item : TripleClick

  window.addEventListener('click', (evt: any) => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
      bookerModal.openModal({});
    }
  });

  // Ï∫îÎ≤ÑÏä§ ÎçîÎ∏îÌÅ¥Î¶≠Ïãú
  const handleCanvasDoubleClick = (group: any, time: any, e: any) => {};

  // Í∞ôÏùÄ ÏòàÏïΩÏûêÍ∞Ä ÏòàÏïΩÌïú Í≤åÏä§Ìä∏Îì§ÏùÑ ÌïúÎ≤àÏóê Î≥ÄÍ≤Ω
  const resizeLinkedItems = (bookerId: string, newTime: number) => {
    // TODO Ïó¨Í∏∞ÏÑú StateÎ•ºÌÜµÌïòÏó¨ Ï°∞ÏûëÌï†Ïàò ÏûàÎèÑÎ°ùÌïòÏûê
    guestValue.forEach((guest) => {
      const inGuest = guest;
      if (guest.bookerId === bookerId) inGuest.end = newTime;
    });
    setGuestValue([...guestValue]);
  };

  // Í∞ôÏùÄ ÏòàÏïΩÏûêÍ∞Ä ÏòàÏïΩÌïú Í≤åÏä§Ìä∏Îì§ÏùÑ ÌïúÎ≤àÏóê Ïù¥Îèô
  const moveLinkedItems = (bookerId: string, newTime: number) => {
    guestValue.forEach((guest) => {
      const inGuest = guest;
      if (guest.bookerId === bookerId) {
        inGuest.end += newTime - guest.start;
        inGuest.start = newTime;
      }
    });
    setGuestValue([...guestValue]);
  };

  // üê≠ ÎßàÏö∞Ïä§ ÏõÄÏßÅÏù¥Î©¥ Ìò∏Ï∂úÎê®
  // ÏÉàÎ°úÏö¥ ÏãúÍ∞ÑÏùÑ Î¶¨ÌÑ¥ÌïòÍ±∞ÎÇò timeÏùÑ Î¶¨ÌÑ¥ÌïòÏÑ∏Ïöî.
  const handleMoveResizeValidator = (
    action: 'move' | 'resize',
    item: IAssigItem,
    time: number,
    resizeEdge: 'left' | 'right' | undefined,
  ): number => {
    if (action === 'resize') {
      // ÏµúÏÜå ÏïÑÏù¥ÌÖúÏ§å ÏÑ§Ï†ï
      if (item.start >= time) return item.end;
      if (setMidNight(new Date().getTime()) >= time) return item.end;

      resizeValidater(item, time);
      resizeLinkedItems(item.bookerId, time);
    }

    if (action === 'move') {
      $(`.assigItem--booker${item.bookerId}`).addClass(CLASS_MOVING);
      $(`#assigItem--guest${item.id}`).removeClass(CLASS_MOVING);

      const targetGroup = groupData.find(group => group.id === item.group);
      // Ïù¥ÎèôÌïòÎäîÍ≥≥ ÏÑ±Î≥Ñ Ï†úÌïú ÌôïÏù∏
      if (targetGroup) {
        // üíîüíîüíîüíî ÏïÑÏù¥ÌÖúÏù¥ Í∏∞Ï°¥ ÏïÑÏù¥ÌÖúÍ≥º ÎèôÏùºÌïú ÏÉÅÌÉúÎùºÏÑú groupÏù¥ New Í∑∏Î£πÏù¥ ÏïÑÎãôÎãàÎã§ „Ö†„Ö†„Ö†
        //  ÏßÄÍ∏à Î™®ÎìàÏù¥ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏù¥ÎùºÍ≥†ÌïòÎãà Í∏∞Îã§Î†§Î¥êÏïºÌï©ÎãàÎã§.
        // (Ïù¥ÎèôÌïòÎäîÍ≥≥:ÎßàÏö∞Ïä§ ÎÅåÍ≥†ÏûàÎäîÍ≥≥)Ïù¥ Î≤†ÎìúÎùºÎ©¥ ?
        // const validateResult = moveValidater(item, targetGroup, time);
        // console.log('‚ú¥Ô∏èvalidateResult');
        // console.log(validateResult);
        // üëΩ STATE ÏÉùÍ∏∏ÏàòÎèÑ ÏûàÏùå!
        // $(`.${CLASS_DISABLE}`).removeClass(CLASS_DISABLE);
        // if (!validateResult) $(`.assigItem--booker${item.bookerId}`).addClass(CLASS_DISABLE);
      }

      // ÌäπÏ†ïÏÑ±Î≥ÑÎ∞©Ïù¥Î©¥ Ï≤¥ÌÅ¨
      // ÌòºÏàôÎ∂àÍ∞Ä Î∞©Ïù¥ÎùºÎ©¥
      // ÏïàÏóê Îì§Ïñ¥ÏûàÎäî ÏÇ¨ÎûåÏùÑ Ï≤¥ÌÅ¨

      // Ïù¥ÎèôÌïòÎäî Î≤†ÎìúÏóê Îã§Î•∏ÏÇ¨ÎûåÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏

      // Ïù¥ÎèôÌïòÎäîÍ≥≥Ïù¥ Î∞©Ïù¥ÎùºÎ©¥?

      moveLinkedItems(item.bookerId, time);
    }

    return time;
  };
  // üê≠ÎßàÏö∞Ïä§ ÎÜìÏïÑÏïº Ìò∏Ï∂úÎê®.
  const handleItemMove = async (itemId: string, dragTime: number, newGroupOrder: number) => {
    const guestValueOriginCopy = guestValue.slice();
    const guestValueCopy = guestValue.slice();
    const targetGuestIndex = guestValue.findIndex(guest => guest.id === itemId);
    guestValueCopy[targetGuestIndex] = {
      ...guestValueCopy[targetGuestIndex],
      group: groupData[newGroupOrder].id,
    };
    setGuestValue([...guestValueCopy]);

    const newGroupId = groupData[newGroupOrder].roomId;

    $(`.${CLASS_MOVING}`).removeClass(CLASS_MOVING);

    const result = await allocateMu({
      variables: {
        guestId: itemId,
        roomId: newGroupId,
        bedIndex: groupData[newGroupOrder].bedIndex,
      },
    });

    if (result && result.data && !result.data.AllocateGuestToRoom.ok) {
      setGuestValue([...guestValueOriginCopy]);
    }
  };

  // üê≠ ÎßàÏö∞Ïä§ ÎÜìÏïÑÏïº Ìò∏Ï∂úÎê®
  const handleItemResize = (itemId: string, time: number, edge: 'left' | 'right') => {};

  const hanldeItemClick = (itemId: string, e: React.MouseEvent<HTMLElement>, time: number) => {
    const target = guestValue.find(guest => guest.id === itemId);

    if (!target) return;
    if (target.bookerId === 'block') return;
    // Ïª®Ìä∏Î°§: Ï≤¥ÌÅ¨Ïù∏
    if (e.ctrlKey) {
      guestValue[target.guestIndex].isCheckin = !guestValue[target.guestIndex].isCheckin;
      setGuestValue([...guestValue]);
    }
    // Ïâ¨ÌîÑÌä∏ ÌåùÏóÖ
    if (e.shiftKey) {
      bookerModal.openModal({ bookerId: target.bookerId });
    }
    // ÏïåÌä∏: Î∞∞Ï†ïÌôïÏ†ï
    if (e.altKey) {
      guestValue[target.guestIndex].isUnsettled = !guestValue[target.guestIndex].isUnsettled;
      setGuestValue([...guestValue]);
    }
  };

  const parallax = () => new Date().getTimezoneOffset() * 1000 * 60;

  const handleCanvasContextMenu = (groupId: string, time: number, e: React.MouseEvent<HTMLElement>) => {

    guestValue.push({
      ...defaultItemProps,
      id: `mark${groupId}${time}`,
      type: 'mark',
      start: time,
      end: time + TimePerMs.DAY,
      group: groupId,
    });

    setGuestValue([...guestValue]);
  };

  // üê≠ ÏïÑÏù¥ÌÖúÏù¥ ÏÑ†ÌÉùÎêòÏóàÏùÑÎïå
  const handleItemSelect = async (itemId: string, e: React.MouseEvent<HTMLElement>, time: number) => {
    const target = guestValue.find(guest => guest.id === itemId);
    if (target) {
      await $('.assigItem').removeClass(CLASS_LINKED);
      $(`.assigItem--booker${target.bookerId}`).addClass(CLASS_LINKED);
    }
  };
  // ÏãúÍ∞ÑÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏùÑÎñÑ
  const handleTimeChange = (visibleTimeStart: number, visibleTimeEnd: number, updateScrollCanvas: any) => {
    updateScrollCanvas(visibleTimeStart, visibleTimeEnd);
  };

  return (
    <div id="AssigTimeline" className="container container--full">
      <div className="docs-section">
        <h3>
          {'Î∞©Î∞∞Ï†ï'}
          {loading && <Preloader />}
        </h3>
        <div className="flex-grid flex-grid--end">
          <Link to="/middleServer/timelineConfig">
            <Button float="right" icon="roomChange" label="Î∞©Íµ¨Ï°∞ Î≥ÄÍ≤Ω" />
          </Link>
        </div>
        <CanvasMenu />
        <ItemMenu />
        <Timeline
          onItemMove={handleItemMove}
          onItemResize={handleItemResize}
          items={guestValue}
          groups={groupData}
          {...defaultProps}
          onItemDoubleClick={handleItemDoubleClick}
          onItemClick={hanldeItemClick}
          onCanvasDoubleClick={handleCanvasDoubleClick}
          onCanvasClick={handleCanvasClick}
          onTimeChange={handleTimeChange}
          groupRenderer={assigGroupRendererFn}
          defaultTimeEnd={defaultTimeEnd}
          defaultTimeStart={defaultTimeStart}
          moveResizeValidator={handleMoveResizeValidator}
          onItemSelect={handleItemSelect}
          onCanvasContextMenu={handleCanvasContextMenu}
        >
          <TimelineHeaders>
            <SidebarHeader>
              {({ getRootProps }: any) => (
                <div className="rct-header-root__topLeft" {...getRootProps()}>
                  <JDdayPicker
                    isRange={false}
                    input
                    canSelectBeforeDays={false}
                    label="Îã¨Î†•ÎÇ†Ïûê"
                    {...dayPickerHook}
                    className="JDwaves-effect JDoverflow-visible"
                    inputComponent={(
                      <span>
                        <JDIcon className="specificPrice__topLeftIcon" size={IconSize.MEDEIUM_SMALL} icon="calendar" />
                      </span>
)}
                  />
                </div>
              )}
            </SidebarHeader>
            <DateHeader height={34} unit="day" />
            <DateHeader />
          </TimelineHeaders>
        </Timeline>
        <BookerModalWrap modalHook={bookerModal} />
      </div>
    </div>
  );
};

export default ErrProtecter(ShowTimeline);
