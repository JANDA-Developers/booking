type CreateBookerResponse {
  ok: Boolean!
  error: String
  booker: Booker
}

type Mutation {
  CreateBooker(houseId: ID!, name: Name!, password: Password!, phoneNumber: PhoneNumber!, email: EmailAddress, agreePrivacyPolicy: Boolean!): CreateBookerResponse!
  CreateBooking(bookingParams: BookingInput!): CreateBookingResponse!
  UpdateBooking(bookingId: ID!, bookingStatus: BookingStatus, start: DateTime, end: DateTime, price: Float): UpdateBookingResponse!
  CreateGuest(houseId: ID!, bookerId: ID!, roomTypeId: ID!, roomId: ID, start: DateTime!, end: DateTime!, gender: Gender!, guestType: GuestType!): CreateGuestResponse!
  # 게스트 생성
  CreateGuests(houseId: ID!, bookerId: ID!, roomTypeId: ID!, roomIds: [ID!], start: DateTime!, end: DateTime!, geustType: GuestType!): CreateGuestsResponse!
  CreateIntergration(houseId: ID!): CreateIntergrationResponse!
  UpdateHouseToHostApp(name: String, houseType: HouseType, location: LocationInput, refundPolicy: [TermsOfRefundInput!], termsOfBooking: TermsOfBookingInput): UpdateHouseToHostAppResponse!
  # 로그인 token 필요함!
  CreateRoomTypeToHostApp(name: String!, pricingType: PricingType!, peopleCount: Int!, peopleCountMax: Int, description: String, tags: [TagInput!]): CreateRoomTypeToHostAppResponse!
  ChangePriorityToHostApp(seasonId: ID!, houseId: ID!, priority: Int!): ChangePriorityToHostAppResponse!
  CreateSeasonToHostApp(name: String!, start: DateTime!, end: DateTime!, color: String, description: String): CreateSeasonToHostAppResponse!
  UpdateSeasonToHostApp(seasonId: ID!, name: String, start: DateTime, end: DateTime, color: String, description: String): UpdateSeasonToHostAppResponse!
  CreateSeasonPriceToHostApp(roomTypeId: ID!, seasonId: ID!, price: Float!, applyDays: Int): CreateSeasonPriceToHostAppResponse!
  UpdateSeasonPriceToHostApp(seasonPriceId: ID!, price: Float, applyDays: Int!): UpdateSeasonPriceToHostAppResponse!
  CreateHouse(name: String!, houseType: HouseType!, location: LocationInput!): CreateHouseResponse!
  DeleteHouse(_id: String!): DeleteHouseResponse!
  UpdateHouse(houseId: ID!, name: String, houseType: HouseType, location: LocationInput, refundPolicy: [TermsOfRefundInput!], termsOfBooking: TermsOfBookingInput): UpdateHouseResponse!
  CreateProduct(name: String!, price: Int, discountedPrice: Int, roomCount: Int, roomCountExtraCharge: Int, bookingCount: Int, bookingCountExtraCharge: Int, description: String): CreateProductResponse!
  BuyProduct(houseId: ID!, productTypeId: ID!): BuyProductResponse!
  CreateProductType(name: String!, price: Int!, roomCount: Int, roomCountExtraCharge: Int, bookingCount: Int, bookingCountExtraCharge: Int, description: String): CreateProductTypeResponse!
  DeleteProductType(productTypeId: ID!): DeleteProductTypeResponse!
  RefundProduct(houseId: ID!, productId: ID!): RefundProductResponse!
  UpdateProductType(productTypeId: ID!, name: String!, price: Int!, roomCount: Int!, roomCountExtraCharge: Int!, bookingCount: Int!, bookingCountExtraCharge: Int!, description: String): UpdateProductTypeResponse!
  CreateRoomPrice(price: Float!, roomTypeId: ID!, date: DateTime!): CreateRoomPriceResponse!
  CreateSeasonPrice(roomTypeId: ID!, seasonId: ID!, price: Float!, applyDays: Int): CreateSeasonPriceResponse!
  UpdateSeasonPrice(seasonPriceId: ID!, price: Float, applyDays: Int!): UpdateSeasonPriceResponse!
  CreateRoom(name: String!, roomType: ID!, disableRange: [DisableRangeInput!]): CreateRoomResponse!
  # 로그인 token 필요함!
  CreateRoomType(name: String!, houseId: ID!, pricingType: PricingType!, peopleCount: Int!, peopleCountMax: Int, description: String, tags: [TagInput!]): CreateRoomTypeResponse!
  DeleteRoom(roomId: ID!): DeleteRoomResponse!
  DeleteRoomType(roomTypeId: ID!, houseId: ID!): DeleteRoomTypeResponse!
  UpdateRoom(roomId: ID!, name: String): UpdateRoomResponse!
  ChangeIndex(roomTypeId: ID!, houseId: ID!, index: Int!): ChangeIndexResponse!
  UpdateRoomType(roomTypeId: ID!, houseId: ID!, name: String, peopleCount: Int, peopleCountMax: Int, description: String): UpdateRoomTypeResponse!
  ChangePriority(seasonId: ID!, houseId: ID!, priority: Int!): ChangePriorityResponse!
  CreateSeason(name: String!, start: DateTime!, end: DateTime!, houseId: ID!, color: String, description: String): CreateSeasonResponse!
  DeleteSeason(seasonId: ID!, houseId: ID!): DeleteSeasonResponse!
  UpdateSeason(seasonId: ID!, name: String, start: DateTime, end: DateTime, color: String, description: String): UpdateSeasonResponse!
  CompletePhoneVerification(key: String!): CompletePhoneVerificationResponse!
  EmailSignUp(name: Name!, email: EmailAddress!, password: Password!, phoneNumber: PhoneNumber!): EmailSignUpResponse!
  GmailConnect(firstName: String!, lastName: String!, gmail: String!): GmailConnectionResponse!
  StartPhoneVerification: StartPhoneVerificationResponse!
  UpdateMyProfile(name: Name!, password: Password!, phoneNumber: PhoneNumber, email: EmailAddress): UpdateMyProfileResponse!
  ChangePassword(currentPassword: Password!, newPassword: Password!, newPasswordRepeat: Password!): ChangePasswordResponse!
}

type Booker {
  _id: ID!
  house: House!
  bookings: [Booking!]
  name: Name!
  password: String
  phoneNumber: PhoneNumber!
  email: EmailAddress
  agreePrivacyPolicy: Boolean!
  isCheckIn: DateTime
  memo: String
  createdAt: DateTime!
  updatedAt: DateTime
}

input BookerInput {
  house: ID!
  booking: ID
  name: Name!
  password: String!
  phoneNumber: PhoneNumber!
  email: EmailAddress
  agreePrivacyPolicy: Boolean!
}

type CreateBookingResponse {
  ok: Boolean!
  error: String
  # 리턴타입 검토중. 
  booking: [Booking!]
}

type Booking {
  _id: ID!
  bookingId: String!
  house: House!
  roomType: RoomType!
  booker: Booker!
  guests: [Guest!]
  # 가격
  price: Float!
  # 시작 날짜
  start: DateTime!
  # 끝 날짜
  end: DateTime!
  discountedPrice: Float!
  bookingStatus: BookingStatus!
  createdAt: DateTime!
  updatedAt: DateTime
}

enum BookingStatus {
  # 입금 대기
  WAIT_DEPOSIT
  # 예약 완료
  COMPLETE
  # 예약 취소(입금 전에 취소를 신청하여 바로 처리되었거나 환불이 완료되어 취소된 상태를 뜻함)
  CANCEL
  # 환불 대기
  REFUND_WAIT
  # 체크인 할떄 방값 지불
  PAY_WHEN_CHK_IN
}

input BookingInput {
  booker: BookerInput!
  start: DateTime!
  end: DateTime!
  guest: [GuestPartInput!]!
}

input GuestPartInput {
  roomTypeId: ID!
  price: Float!
  discountedPrice: Float
  guestType: GuestType!
  count: Int!
  genders: [Gender!]
}

type UpdateBookingResponse {
  ok: Boolean!
  error: String
  booking: [Booking!]
}

scalar DateTime

scalar EmailAddress

scalar Name

scalar Password

scalar PhoneNumber

scalar URL

# DB에 저장할 떄는 0101010의 형태로 저장하도록 Resolver에서 처리한다.
enum Day {
  SUN
  MON
  TUE
  WED
  THU
  FRI
  SAT
}

type Tag {
  name: String!
  content: String!
  icon: String!
}

input TagInput {
  name: String!
  content: String!
  icon: String
}

# 이하 프론트에서 필요한 input 요청
input SelectOption {
  value: String!
  label: String!
}

enum DateRangeStatus {
  PAST
  PRESENT
  FUTURE
}

type DateRange {
  hashCode: Int!
  startDate: DateTime
  endDate: DateTime
}

input DateRangeInput {
  startDate: DateTime
  endDate: DateTime
}

type DisableRange {
  hashCode: Int!
  startDate: DateTime
  endDate: DateTime
  description: String
}

input DisableRangeInput {
  startDate: DateTime
  endDate: DateTime
  description: String
}

type Location {
  address: String!
  addressDetail: String
  lat: Float!
  lng: Float!
}

input LocationInput {
  address: String!
  addressDetail: String
  lat: Float!
  lng: Float!
}

type CreateGuestResponse {
  ok: Boolean!
  error: String
  guest: Guest
}

type CreateGuestsResponse {
  ok: Boolean!
  error: String
  guests: [Guest!]
}

type Guest {
  _id: ID!
  # roomType,
  guestId: String!
  booker: Booker!
  house: House!
  # roomType 은 처음 예약하고나서 절대로 변경되지 않음.
  roomType: RoomType
  # 현재 묵는 방으로 변경될수 있음.
  room: Room
  booking: Booking
  name: Name
  start: DateTime!
  end: DateTime!
  # 도미토리, 룸, 블록 구분
  guestType: GuestType!
  gender: Gender
  createdAt: DateTime!
  updatedAt: DateTime
}

enum GuestType {
  # 방 막는 용도로 잡은 예약임
  BLOCK_ROOM
  # 도미토리
  DOMITORY
  # 방 타입
  ROOM
}

# 도미토리 방식으로 예약한 게스트만 적용됨
enum Gender {
  # 도미토리 남
  MALE
  # 도미토리 여
  FEMALE
}

input GuestInput {
  houseId: ID!
  bookerId: ID!
  roomTypeId: ID!
  roomId: ID
  bookingId: ID!
  start: DateTime!
  end: DateTime!
  guestType: GuestType!
  gender: Gender
}

input GuestsInput {
  houseId: ID!
  bookerId: ID!
  bookingId: ID
  roomTypeId: ID!
  start: DateTime!
  end: DateTime!
  guestType: [GuestType!]!
  gender: [Gender!]
  roomId: [ID!]
}

type CreateIntergrationResponse {
  ok: Boolean!
  error: String
  token: String
}

type GetAllHouseToHostAppResponse {
  ok: Boolean!
  error: String
  houses: [House!]
}

type Query {
  GetAllHouseToHostApp(email: EmailAddress!, password: Password!): GetAllHouseToHostAppResponse!
  GetHouse(houseId: ID!): GetHouseResponse!
  GetAllProducts: GetAllProductsResponse!
  GetAllProductTypes: GetAllProductTypesResponse!
  GetRoomPriceWithDateRange(roomTypeId: ID!, start: DateTime!, end: DateTime!): GetRoomPriceWithDateRangeResponse!
  GetSeasonPriceWithDateRange(roomTypeId: ID!, start: DateTime!, end: DateTime!): GetSeasonPriceWithDateRangeResponse!
  GetAllRoomType(houseId: ID!): GetAllRoomTypeResponse!
  GetSeasonWithDate(houseId: ID!, date: DateTime!): GetSeasonWithDateResponse!
  # DateRange안에 해당하는 Season을 구함
  GetSeasonWithDateRange(houseId: ID!, start: DateTime!, end: DateTime!): GetSeasonWithDateRangeResponse!
  EmailSignIn(email: EmailAddress!, password: Password!): EmailSignInResponse!
  # 로그인 token 필요!
  GetMyProfile: GetMyProfileResponse!
}

type UpdateHouseToHostAppResponse {
  ok: Boolean!
  error: String
  house: House
}

type CreateRoomTypeToHostAppResponse {
  ok: Boolean!
  error: String
  roomType: RoomType
}

type ChangePriorityToHostAppResponse {
  ok: Boolean!
  error: String
  season: Season
}

type CreateSeasonToHostAppResponse {
  ok: Boolean!
  error: String
  season: Season
}

type UpdateSeasonToHostAppResponse {
  ok: Boolean
  error: String
  season: Season
}

type CreateSeasonPriceToHostAppResponse {
  ok: Boolean!
  error: String
  seasonPrice: SeasonPrice
}

type UpdateSeasonPriceToHostAppResponse {
  ok: Boolean!
  error: String
  seasonPrice: SeasonPrice
}

type HostApplication {
  _id: ID!
  applicationType: ApplicationType!
  house: House!
  user: User!
  url: URL!
  hostApplicationAdmin: HostApplicationAdmin!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
}

enum ApplicationType {
  BOOKING_WEB
}

type HostApplicationAdmin {
  _id: ID!
  name: String
  password: String
  createdAt: DateTime!
  updatedAt: DateTime
}

type CreateHouseResponse {
  ok: Boolean!
  error: String
  house: House
}

type DeleteHouseResponse {
  ok: Boolean!
  error: String
}

type GetHouseResponse {
  ok: Boolean!
  error: String
  house: House
}

type House {
  _id: ID!
  name: String!
  houseType: HouseType!
  product: Product
  user: User!
  location: Location!
  refundPolicy: [TermsOfRefund!]!
  termsOfBooking: TermsOfBooking!
  createdAt: DateTime!
  updatedAt: DateTime
}

enum HouseType {
  GUEST_HOUSE
  HOSTEL
  HOTEL
  MOTEL
  PENSION
  YOUTH_HOSTEL
}

# 예약 가능한 조건.
type TermsOfBooking {
  # 선택 가능한 가장 멀리있는 날짜(today 를 기준으로 ~일 뒤)
  farthestSelectableDate: Int!
  # 선택 가능한 가장 가까히 있는 날짜(today 를 기준으로 ~일 뒤)
  nearestSelectableDate: Int!
  # 선택 가능 날짜 범위
  selectableDateRange: Int!
}

type TermsOfRefund {
  # 환불 가능 기간: 숙박일로부터 ~일 전
  beforeDays: Int!
  rate: Float!
  description: String
}

input TermsOfRefundInput {
  beforeDays: Int!
  rate: Float!
  description: String
}

input TermsOfBookingInput {
  # 선택 가능한 가장 멀리있는 날짜(today 를 기준으로 ~일 뒤)
  farthestSelectableDate: Int!
  # 선택 가능한 가장 가까히 있는 날짜(today 를 기준으로 ~일 뒤)
  nearestSelectableDate: Int!
  # 선택 가능 날짜 범위
  selectableDateRange: Int!
}

type UpdateHouseResponse {
  ok: Boolean!
  error: String
  house: House
}

type CreateProductResponse {
  ok: Boolean!
  error: String
  product: Product
}

type GetAllProductsResponse {
  ok: Boolean!
  error: String
  products: [Product!]
}

type Product {
  _id: ID!
  # 제품 이름
  name: String!
  # 제품 가격(월)
  price: Int
  # 할인된 가격
  discountedPrice: Int
  # 만들 수 있는 최대 방 / 배드 수 => -1 일때 무제한
  roomCount: Int
  # 방 수 추가시 추가 가격  => default: 0
  roomCountExtraCharge: Int
  # 한달간 받을 수 있는 최대 예약 수 => -1 일 떄 무제한
  bookingCount: Int
  # 예약 초과시 부과되는 금액 => defualt: 0
  bookingCountExtraCharge: Int
  # 상세 설명
  house: House!
  productType: ProductType!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
}

type BuyProductResponse {
  ok: Boolean!
  error: String
  product: Product
}

type CreateProductTypeResponse {
  ok: Boolean!
  error: String
  productType: ProductType
}

type DeleteProductTypeResponse {
  ok: Boolean!
  error: String
}

type GetAllProductTypesResponse {
  ok: Boolean!
  error: String
  productTypes: [ProductType!]
}

type RefundProductResponse {
  ok: Boolean!
  error: String
  house: House
}

type ProductType {
  _id: ID!
  # 제품 이름
  name: String!
  # 제품 가격(월)
  price: Int!
  # 만들 수 있는 최대 방 / 배드 수 => -1 일때 무제한
  roomCount: Int!
  # 방 수 추가시 추가 가격  => default: 0
  roomCountExtraCharge: Int!
  # 한달간 받을 수 있는 최대 예약 수 => -1 일 떄 무제한
  bookingCount: Int!
  # 예약 초과시 부과되는 금액 => defualt: 0
  bookingCountExtraCharge: Int!
  # 상세 설명
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
}

type UpdateProductTypeResponse {
  ok: Boolean!
  error: String
  productType: ProductType
}

type CreateRoomPriceResponse {
  ok: Boolean!
  error: String
  roomPrice: RoomPrice
}

type CreateSeasonPriceResponse {
  ok: Boolean!
  error: String
  seasonPrice: SeasonPrice
}

type GetRoomPriceWithDateRangeResponse {
  ok: Boolean!
  error: String
  roomPrices: [RoomPrice!]
}

type GetSeasonPriceWithDateRangeResponse {
  ok: Boolean!
  error: String
  seasonPrices: [SeasonPrice!]
}

type DateRangeWithSeasonPrice {
  start: DateTime!
  end: DateTime!
  # 시즌 가격: null인 경우 방의 기본 가격으로 적용
  seasonPrice: SeasonPrice
}

type RoomPrice {
  _id: ID!
  roomType: RoomType!
  price: Float!
  date: DateTime!
}

type SeasonPrice {
  _id: ID!
  roomType: RoomType!
  season: Season!
  price: Float!
  applyDays: String!
}

input SeasonPriceInput {
  price: Float!
  applyDays: Int!
}

type UpdateSeasonPriceResponse {
  ok: Boolean!
  error: String
  seasonPrice: SeasonPrice
}

type CreateRoomResponse {
  ok: Boolean
  error: String
  room: Room
}

type CreateRoomTypeResponse {
  ok: Boolean!
  error: String
  roomType: RoomType
}

type DeleteRoomResponse {
  ok: Boolean!
  error: String
}

type DeleteRoomTypeResponse {
  ok: Boolean!
  error: String
}

type GetAllRoomTypeResponse {
  ok: Boolean
  error: String
  roomTypes: [RoomType!]
}

type Room {
  _id: ID!
  name: String!
  roomType: RoomType!
  index: Int!
  createdAt: DateTime!
  updatedAt: DateTime
}

type RoomType {
  _id: ID!
  name: String!
  house: House!
  pricingType: PricingType!
  peopleCount: Int!
  peopleCountMax: Int!
  index: Int!
  roomCount: Int!
  roomGender: RoomGender!
  description: String
  # 일괄적으로 적용되는 기본 방 가격... RoomPrice, SeasonPrice가 없는 경우 이 가격을 적용함.
  price: Float
  # 예전에 Facilities 랑 같은 아이임...
  tags: [Tag!]!
  rooms: [Room!]!
  createdAt: DateTime!
  updatedAt: DateTime
}

enum PricingType {
  DOMITORY
  ROOM
}

enum RoomGender {
  MAKE
  FEMALE
  MIXED
  SEPARATELY
}

type UpdateRoomResponse {
  ok: Boolean!
  error: String
}

type ChangeIndexResponse {
  ok: Boolean!
  error: String
}

type UpdateRoomTypeResponse {
  ok: Boolean!
  error: String
  roomType: RoomType
}

type ChangePriorityResponse {
  ok: Boolean!
  error: String
  season: Season
}

type CreateSeasonResponse {
  ok: Boolean!
  error: String
  season: Season
}

type DeleteSeasonResponse {
  ok: Boolean!
  error: String
}

type GetSeasonWithDateResponse {
  ok: Boolean!
  error: String
  season: Season
}

type GetSeasonWithDateRangeResponse {
  ok: Boolean!
  error: String
  seasons: [Season!]
}

# 날짜 범위에 Season을 포함.
type DateRangeWithSeason {
  # 시작 날짜
  start: DateTime!
  # 끝 날짜
  end: DateTime!
  # 해당되는 시즌
  season: Season!
}

type Season {
  _id: ID!
  house: House!
  name: String!
  start: DateTime!
  end: DateTime!
  priority: Int!
  color: String
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
}

type UpdateSeasonResponse {
  ok: Boolean
  error: String
  season: Season
}

type CompletePhoneVerificationResponse {
  ok: Boolean!
  error: String
}

type EmailSignInResponse {
  ok: Boolean!
  error: String
  token: String
}

type EmailSignUpResponse {
  ok: Boolean!
  error: String
  token: String
}

type GetMyProfileResponse {
  ok: Boolean!
  error: String
  user: User
}

type GmailConnectionResponse {
  ok: Boolean!
  error: String
  token: String
}

type User {
  _id: ID!
  name: Name!
  phoneNumber: PhoneNumber!
  password: Password
  email: EmailAddress!
  isPhoneVerified: Boolean!
  isEmailVerified: Boolean!
  userRole: UserRole!
  checkPrivacyPolicy: Boolean!
  houses: [House!]!
  createdAt: DateTime!
  updatedAt: DateTime
}

enum UserRole {
  ADMIN
  HOST
  GUEST
  # 비회원 => name, phoneNumber, password, email, createdAt, updatedAt 데이터 만을 가짐
  GHOST
}

type StartPhoneVerificationResponse {
  ok: Boolean!
  error: String
}

type UpdateMyProfileResponse {
  ok: Boolean!
  error: String
  user: User
}

type ChangePasswordResponse {
  ok: Boolean!
  error: String
}

type Verification {
  _id: ID!
  target: VerificationTarget!
  payload: String!
  verified: Boolean!
  key: String!
  user: User!
  createdAt: String!
  updatedAt: String
}

enum VerificationTarget {
  PHONE
  EMAIL
}
