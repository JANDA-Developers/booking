From 119ef3df2465ad20982effd321df4a6d729db5df Mon Sep 17 00:00:00 2001
From: BaeKY <ksc2601@gmail.com>
Date: Wed, 13 Mar 2019 18:59:44 +0900
Subject: [PATCH] =?UTF-8?q?Merge.ts=20=ED=8C=8C=EC=9D=BC=20=EC=9C=84?=
 =?UTF-8?q?=EC=B9=98=20=EB=B3=80=EA=B2=BD=20=EB=B0=8F=20queries.ts=20?=
 =?UTF-8?q?=EC=B6=94=EA=B0=80?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 server/src/api/Common/scalars/DateTime.scalar.ts   |  14 +-
 server/src/api/Common/shared/DateRange.graphql     |   5 +-
 server/src/api/Guest/shared/Guest.graphql          |  25 +-
 .../api/House/CreateHouse/CreateHouse.resolvers.ts |   2 +-
 .../api/House/UpdateHouse/UpdateHouse.resolvers.ts |   2 +-
 .../RoomType/CreateRoom/CreateRoom.resolvers.ts    |   2 +-
 .../CreateRoomType/CreateRoomType.resolvers.ts     |   2 +-
 .../RoomType/GetAllRoomType/GetAllRoomType.graphql |   2 +-
 .../GetAllRoomType/GetAllRoomType.resolvers.ts     |  26 +-
 .../UpdateRoomType/ChangeIndex.resolvers.ts        |  21 +-
 .../UpdateRoomType/UpdateRoomType.resolvers.ts     |   2 +-
 .../Season/ChangePriority/ChangePriority.graphql   |  12 +
 .../ChangePriority/ChangePriority.resolvers.ts     |  59 +++++
 .../api/Season/CreateSeason/CreateSeason.graphql   |  14 ++
 .../Season/CreateSeason/CreateSeason.resolvers.ts  |  44 ++++
 .../api/Season/UpdateSeason/UpdateSeason.graphql   |  15 ++
 .../Season/UpdateSeason/UpdateSeason.resolvers.ts  |  61 +++++
 .../User/GetMyProfile/GetMyProfile.resolvers.ts    |   2 +-
 server/src/api/User/shared/User.graphql            |   3 +-
 server/src/dtos/DateRange.class.ts                 | 280 +++++++++++++++++++++
 server/src/dtos/DisableRange.class.ts              |  19 ++
 server/src/models/House.ts                         |   6 +-
 server/src/models/Merge.ts                         | 116 ---------
 server/src/models/Room.ts                          |   8 +-
 server/src/models/RoomType.ts                      |   2 +-
 server/src/models/Season.ts                        |  55 ++++
 server/src/models/User.ts                          |   2 +-
 server/src/models/merge/Merge.ts                   | 249 ++++++++++++++++++
 server/src/queries/queries.ts                      |  74 ++++++
 server/src/utils/DateRange.class.ts                | 100 --------
 server/src/utils/DisableRange.class.ts             |  12 -
 server/tslint.json                                 |   3 +-
 32 files changed, 959 insertions(+), 280 deletions(-)
 create mode 100644 server/src/api/Season/ChangePriority/ChangePriority.graphql
 create mode 100644 server/src/api/Season/ChangePriority/ChangePriority.resolvers.ts
 create mode 100644 server/src/api/Season/CreateSeason/CreateSeason.graphql
 create mode 100644 server/src/api/Season/CreateSeason/CreateSeason.resolvers.ts
 create mode 100644 server/src/api/Season/UpdateSeason/UpdateSeason.graphql
 create mode 100644 server/src/api/Season/UpdateSeason/UpdateSeason.resolvers.ts
 create mode 100644 server/src/dtos/DateRange.class.ts
 create mode 100644 server/src/dtos/DisableRange.class.ts
 delete mode 100644 server/src/models/Merge.ts
 create mode 100644 server/src/models/Season.ts
 create mode 100644 server/src/models/merge/Merge.ts
 create mode 100644 server/src/queries/queries.ts
 delete mode 100644 server/src/utils/DateRange.class.ts
 delete mode 100644 server/src/utils/DisableRange.class.ts

diff --git a/server/src/api/Common/scalars/DateTime.scalar.ts b/server/src/api/Common/scalars/DateTime.scalar.ts
index 767bfbc..561c7fd 100644
--- a/server/src/api/Common/scalars/DateTime.scalar.ts
+++ b/server/src/api/Common/scalars/DateTime.scalar.ts
@@ -2,13 +2,21 @@ import { GraphQLScalarType } from "graphql";
 import { Kind } from "graphql/language";
 
 function serialize(value: string) {
-    return new Date(value).toISOString();
+    const date = new Date(value);
+    // date.setTime(date.getTime() - date.getTimezoneOffset() * 1000 * 60);
+    // console.log({
+    //     date
+    // });
+    
+    return date.toISOString();
 }
 
 function parseValue(value: any) {
     const tov = typeof value;
-    if (tov === "string" || tov === "number") {
-        return new Date(value);
+    if (tov === "string") {
+        return new Date(value).getTime();
+    } else if (tov === "number") {
+        return value;
     } else if (value instanceof Date) {
         return value;
     } else {
diff --git a/server/src/api/Common/shared/DateRange.graphql b/server/src/api/Common/shared/DateRange.graphql
index 132d82f..fa9e8e2 100644
--- a/server/src/api/Common/shared/DateRange.graphql
+++ b/server/src/api/Common/shared/DateRange.graphql
@@ -5,10 +5,9 @@ enum DateRangeStatus {
 }
 
 type DateRange {
+    hashCode: Int!
     startDate: DateTime
-    # null인 경우 startDate 로부터 기약없이 나아감...
     endDate: DateTime
-    status: DateRangeStatus!
 }
 
 input DateRangeInput {
@@ -17,10 +16,10 @@ input DateRangeInput {
 }
 
 type DisableRange {
+    hashCode: Int!
     startDate: DateTime
     endDate: DateTime
     description: String
-    status: DateRangeStatus!
 }
 
 input DisableRangeInput {
diff --git a/server/src/api/Guest/shared/Guest.graphql b/server/src/api/Guest/shared/Guest.graphql
index fe16cb6..5a48e67 100644
--- a/server/src/api/Guest/shared/Guest.graphql
+++ b/server/src/api/Guest/shared/Guest.graphql
@@ -1,14 +1,21 @@
 type Guest {
     _id: ID!
     house: House!
-    booker: User!
-    roomType: String!
-    guestType: String!
-    allocatedRoom: Room!
-    stay: String!
-    price: Int!
+    booking: Booking!
+    room: Room!
+    dateRange: DateRange!
+    guestType: GuestType!
+    price: Float!
     isChkIn: Boolean!
-    bookingId: String!
-    createdAt: String!
-    updatedAt: String
+    createdAt: DateTime!
+    updatedAt: DateTime
+}
+
+enum GuestType {
+    # 방 막는 용도로 잡은 예약임
+    BLOCK_ROOM
+    # 도미토리 형식의 방을 예약한 게스트
+    DOMITORY
+    # 방 타입 예약
+    ROOM
 }
\ No newline at end of file
diff --git a/server/src/api/House/CreateHouse/CreateHouse.resolvers.ts b/server/src/api/House/CreateHouse/CreateHouse.resolvers.ts
index 97971d4..0685d40 100644
--- a/server/src/api/House/CreateHouse/CreateHouse.resolvers.ts
+++ b/server/src/api/House/CreateHouse/CreateHouse.resolvers.ts
@@ -1,6 +1,6 @@
 import { InstanceType } from "typegoose";
 import { HouseModel } from "../../../models/House";
-import { extractHouse } from "../../../models/Merge";
+import { extractHouse } from "../../../models/merge/Merge";
 import { UserSchema } from "../../../models/User";
 import {
     CreateHouseMutationArgs,
diff --git a/server/src/api/House/UpdateHouse/UpdateHouse.resolvers.ts b/server/src/api/House/UpdateHouse/UpdateHouse.resolvers.ts
index 1053146..548af6c 100644
--- a/server/src/api/House/UpdateHouse/UpdateHouse.resolvers.ts
+++ b/server/src/api/House/UpdateHouse/UpdateHouse.resolvers.ts
@@ -1,6 +1,6 @@
 import { ObjectId } from "bson";
 import { HouseModel } from "../../../models/House";
-import { extractHouse } from "../../../models/Merge";
+import { extractHouse } from "../../../models/merge/Merge";
 import {
     UpdateHouseMutationArgs,
     UpdateHouseResponse
diff --git a/server/src/api/RoomType/CreateRoom/CreateRoom.resolvers.ts b/server/src/api/RoomType/CreateRoom/CreateRoom.resolvers.ts
index c6f9fd6..d0b876d 100644
--- a/server/src/api/RoomType/CreateRoom/CreateRoom.resolvers.ts
+++ b/server/src/api/RoomType/CreateRoom/CreateRoom.resolvers.ts
@@ -1,5 +1,5 @@
 import { ObjectId } from "bson";
-import { extractRoom } from "../../../models/Merge";
+import { extractRoom } from "../../../models/merge/Merge";
 import { RoomModel } from "../../../models/Room";
 import { RoomTypeModel } from "../../../models/RoomType";
 import {
diff --git a/server/src/api/RoomType/CreateRoomType/CreateRoomType.resolvers.ts b/server/src/api/RoomType/CreateRoomType/CreateRoomType.resolvers.ts
index 27a9879..741ec51 100644
--- a/server/src/api/RoomType/CreateRoomType/CreateRoomType.resolvers.ts
+++ b/server/src/api/RoomType/CreateRoomType/CreateRoomType.resolvers.ts
@@ -1,7 +1,7 @@
 import { ObjectId } from "bson";
 import { InstanceType } from "typegoose";
 import { HouseModel } from "../../../models/House";
-import { extractRoomType } from "../../../models/Merge";
+import { extractRoomType } from "../../../models/merge/Merge";
 import { RoomTypeModel } from "../../../models/RoomType";
 import { UserSchema } from "../../../models/User";
 import {
diff --git a/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.graphql b/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.graphql
index 770d366..3ac1289 100644
--- a/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.graphql
+++ b/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.graphql
@@ -4,5 +4,5 @@ type GetAllRoomTypeResponse {
     roomTypes: [RoomType!]
 }
 type Query {
-    GetAllRoomType(houseId: ID): GetAllRoomTypeResponse!
+    GetAllRoomType(houseId: ID!): GetAllRoomTypeResponse!
 }
diff --git a/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.resolvers.ts b/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.resolvers.ts
index 684e322..57528c1 100644
--- a/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.resolvers.ts
+++ b/server/src/api/RoomType/GetAllRoomType/GetAllRoomType.resolvers.ts
@@ -1,5 +1,5 @@
-import { ObjectId } from "bson";
-import { extractRoomTypes } from "../../../models/Merge";
+import { HouseModel } from "../../../models/House";
+import { extractRoomTypes } from "../../../models/merge/Merge";
 import {
     GetAllRoomTypeQueryArgs,
     GetAllRoomTypeResponse
@@ -13,23 +13,25 @@ const resolvers: Resolvers = {
             async (
                 _,
                 { houseId }: GetAllRoomTypeQueryArgs,
-                { req }
             ): Promise<GetAllRoomTypeResponse> => {
                 try {
-                    if (houseId) {
+                    const house = await HouseModel.findOne(
+                        { _id: houseId },
+                        { roomTypes: 1 }
+                    );
+                    if (house) {
                         return {
                             ok: true,
                             error: null,
-                            roomTypes: await extractRoomTypes(
-                                new ObjectId(houseId)
-                            )
+                            roomTypes: await extractRoomTypes(house.roomTypes)
+                        };
+                    } else {
+                        return {
+                            ok: false,
+                            error: "Under Delveop",
+                            roomTypes: []
                         };
                     }
-                    return {
-                        ok: false,
-                        error: "Under Delveop",
-                        roomTypes: []
-                    };
                 } catch (error) {
                     return {
                         ok: false,
diff --git a/server/src/api/RoomType/UpdateRoomType/ChangeIndex.resolvers.ts b/server/src/api/RoomType/UpdateRoomType/ChangeIndex.resolvers.ts
index 7821912..fe02450 100644
--- a/server/src/api/RoomType/UpdateRoomType/ChangeIndex.resolvers.ts
+++ b/server/src/api/RoomType/UpdateRoomType/ChangeIndex.resolvers.ts
@@ -1,6 +1,7 @@
 import { ObjectId } from "bson";
 import { InstanceType } from "typegoose";
 import { RoomTypeModel, RoomTypeSchema } from "../../../models/RoomType";
+import { selectNumberRange } from "../../../queries/queries";
 import {
     ChangeIndexMutationArgs,
     ChangeIndexResponse
@@ -19,25 +20,21 @@ const resolvers: Resolvers = {
                 try {
                     const existingRoomType: InstanceType<RoomTypeSchema> =
                         context.existingRoomType;
+                    // 우선 존재하는 roomType의 index를 먼저 업데이트함.
                     await existingRoomType.update({
                         index: args.index
                     });
-                    const gt = args.index;
-                    const lt = existingRoomType.index;
-                    let increment = 1;
-                    let indexCondition: any;
-                    if (gt > lt) {
-                        increment = -1;
-                        indexCondition = { $gt: lt, $lte: gt };
-                    } else {
-                        indexCondition = { $gte: gt, $lt: lt };
-                    }
+                    const conditions = selectNumberRange(
+                        args.index,
+                        existingRoomType.index
+                    );
+
                     await RoomTypeModel.updateMany(
                         {
                             _id: { $ne: new ObjectId(args.roomTypeId) },
-                            index: indexCondition
+                            index: conditions.condition
                         },
-                        { $inc: { index: increment } },
+                        { $inc: { index: conditions.increment } },
                         { new: true }
                     );
                     return {
diff --git a/server/src/api/RoomType/UpdateRoomType/UpdateRoomType.resolvers.ts b/server/src/api/RoomType/UpdateRoomType/UpdateRoomType.resolvers.ts
index 13ea7a7..51f3248 100644
--- a/server/src/api/RoomType/UpdateRoomType/UpdateRoomType.resolvers.ts
+++ b/server/src/api/RoomType/UpdateRoomType/UpdateRoomType.resolvers.ts
@@ -1,5 +1,5 @@
 import { InstanceType } from "typegoose";
-import { extractRoomType } from "../../../models/Merge";
+import { extractRoomType } from "../../../models/merge/Merge";
 import { RoomTypeSchema } from "../../../models/RoomType";
 import {
     UpdateRoomTypeMutationArgs,
diff --git a/server/src/api/Season/ChangePriority/ChangePriority.graphql b/server/src/api/Season/ChangePriority/ChangePriority.graphql
new file mode 100644
index 0000000..edf80df
--- /dev/null
+++ b/server/src/api/Season/ChangePriority/ChangePriority.graphql
@@ -0,0 +1,12 @@
+type ChangePriorityResponse {
+    ok: Boolean!
+    error: String
+    season: Season
+}
+type Mutation {
+    ChangePriority(
+        seasonId: ID!
+        houseId: ID!
+        priority: Int!
+    ): ChangePriorityResponse!
+}
diff --git a/server/src/api/Season/ChangePriority/ChangePriority.resolvers.ts b/server/src/api/Season/ChangePriority/ChangePriority.resolvers.ts
new file mode 100644
index 0000000..f39a925
--- /dev/null
+++ b/server/src/api/Season/ChangePriority/ChangePriority.resolvers.ts
@@ -0,0 +1,59 @@
+import { ObjectId } from "bson";
+import { SeasonModel } from "../../../models/Season";
+import { selectNumberRange } from "../../../queries/queries";
+import {
+    ChangePriorityMutationArgs,
+    ChangePriorityResponse
+} from "../../../types/graph";
+import { Resolvers } from "../../../types/resolvers";
+import privateResolver from "../../../utils/privateResolvers";
+
+const resolvers: Resolvers = {
+    Mutation: {
+        ChangePriority: privateResolver(
+            async (
+                _,
+                { houseId, seasonId, priority }: ChangePriorityMutationArgs
+            ): Promise<ChangePriorityResponse> => {
+                const existingSeasons = await SeasonModel.find(
+                    {
+                        house: new ObjectId(houseId)
+                    },
+                    {
+                        priority: 1
+                    }
+                );
+                if (existingSeasons.length) {
+                    const originalPriority = existingSeasons.filter(
+                        season => season._id === seasonId
+                    )[0].priority;
+                    const conditions = selectNumberRange(
+                        originalPriority,
+                        priority
+                    );
+                    await SeasonModel.updateMany(
+                        {
+                            _id: { $ne: new ObjectId(seasonId) },
+                            priority: conditions.condition
+                        },
+                        { $inc: { priority: conditions.increment } },
+                        { new: true }
+                    );
+                } else {
+                    return {
+                        ok: false,
+                        error: "Other Season is not Exist",
+                        season: null
+                    };
+                }
+                return {
+                    ok: false,
+                    error: "UnderDevelop",
+                    season: null
+                };
+            }
+        )
+    }
+};
+
+export default resolvers;
diff --git a/server/src/api/Season/CreateSeason/CreateSeason.graphql b/server/src/api/Season/CreateSeason/CreateSeason.graphql
new file mode 100644
index 0000000..ab7264a
--- /dev/null
+++ b/server/src/api/Season/CreateSeason/CreateSeason.graphql
@@ -0,0 +1,14 @@
+type CreateSeasonResponse {
+    ok: Boolean!
+    error: String
+    season: Season
+}
+type Mutation {
+    CreateSeason(
+        name: String!
+        houseId: ID!
+        dateRange: DateRangeInput!
+        color: String
+        description: String
+    ): CreateSeasonResponse!
+}
diff --git a/server/src/api/Season/CreateSeason/CreateSeason.resolvers.ts b/server/src/api/Season/CreateSeason/CreateSeason.resolvers.ts
new file mode 100644
index 0000000..91bdb2b
--- /dev/null
+++ b/server/src/api/Season/CreateSeason/CreateSeason.resolvers.ts
@@ -0,0 +1,44 @@
+import { HouseModel } from "../../../models/House";
+import { extractSeason } from "../../../models/merge/Merge";
+import { SeasonModel } from "../../../models/Season";
+import {
+    CreateSeasonMutationArgs,
+    CreateSeasonResponse
+} from "../../../types/graph";
+import { Resolvers } from "../../../types/resolvers";
+import privateResolver from "../../../utils/privateResolvers";
+
+const resolvers: Resolvers = {
+    Mutation: {
+        CreateSeason: privateResolver(
+            async (
+                _,
+                { houseId, name, dateRange, ...args }: CreateSeasonMutationArgs
+            ): Promise<CreateSeasonResponse> => {
+                const existingHouse = await HouseModel.findById(houseId);
+                if (existingHouse) {
+                    const season = new SeasonModel({
+                        name,
+                        house: houseId,
+                        dateRange,
+                        ...args
+                    });
+                    await season.save();
+
+                    return {
+                        ok: true,
+                        error: null,
+                        season: await extractSeason(season)
+                    };
+                } else {
+                    return {
+                        ok: false,
+                        error: "Nothing Match with HouseId",
+                        season: null
+                    };
+                }
+            }
+        )
+    }
+};
+export default resolvers;
diff --git a/server/src/api/Season/UpdateSeason/UpdateSeason.graphql b/server/src/api/Season/UpdateSeason/UpdateSeason.graphql
new file mode 100644
index 0000000..7c2a5d3
--- /dev/null
+++ b/server/src/api/Season/UpdateSeason/UpdateSeason.graphql
@@ -0,0 +1,15 @@
+type UpdateSeasonResponse {
+    ok: Boolean
+    error: String
+    season: Season
+}
+type Mutation {
+    UpdateSeason(
+        seasonId: ID!
+        houseId: ID!
+        name: String
+        dateRange: DateRangeInput
+        color: String
+        description: String
+    ): UpdateSeasonResponse!
+}
diff --git a/server/src/api/Season/UpdateSeason/UpdateSeason.resolvers.ts b/server/src/api/Season/UpdateSeason/UpdateSeason.resolvers.ts
new file mode 100644
index 0000000..77d23ab
--- /dev/null
+++ b/server/src/api/Season/UpdateSeason/UpdateSeason.resolvers.ts
@@ -0,0 +1,61 @@
+import { ObjectId } from "bson";
+import { extractSeason } from "../../../models/merge/Merge";
+import { SeasonModel } from "../../../models/Season";
+import {
+    UpdateSeasonMutationArgs,
+    UpdateSeasonResponse
+} from "../../../types/graph";
+import { Resolvers } from "../../../types/resolvers";
+import privateResolver from "../../../utils/privateResolvers";
+
+const resolvers: Resolvers = {
+    Mutation: {
+        UpdateSeason: privateResolver(
+            async (
+                _,
+                {
+                    seasonId,
+                    houseId,
+                    dateRange,
+                    ...args
+                }: UpdateSeasonMutationArgs
+            ): Promise<UpdateSeasonResponse> => {
+                try {
+                    let updateQuery = args;
+                    if (dateRange) {
+                        // 중복검사가 필요함 ㅎㅎ
+                        // const newDateRange = new DateRange(dateRange, {
+                        //     ignoreYear: true
+                        // });
+
+                        updateQuery = {
+                            ...updateQuery,
+                            ...dateRange
+                        };
+                    }
+                    const updatedSeason = await SeasonModel.updateOne(
+                        {
+                            _id: new ObjectId(seasonId)
+                        },
+                        updateQuery,
+                        {
+                            new: true
+                        }
+                    );
+                    return {
+                        ok: false,
+                        error: "Under Development",
+                        season: await extractSeason(updatedSeason)
+                    };
+                } catch (error) {
+                    return {
+                        ok: false,
+                        error: error.message,
+                        season: null
+                    };
+                }
+            }
+        )
+    }
+};
+export default resolvers;
diff --git a/server/src/api/User/GetMyProfile/GetMyProfile.resolvers.ts b/server/src/api/User/GetMyProfile/GetMyProfile.resolvers.ts
index 2c3fc65..27ac71f 100644
--- a/server/src/api/User/GetMyProfile/GetMyProfile.resolvers.ts
+++ b/server/src/api/User/GetMyProfile/GetMyProfile.resolvers.ts
@@ -1,4 +1,4 @@
-import { extractUser } from "../../../models/Merge";
+import { extractUser } from "../../../models/merge/Merge";
 import { GetMyProfileResponse } from "../../../types/graph";
 import { Resolvers } from "../../../types/resolvers";
 import privateResolver from "../../../utils/privateResolvers";
diff --git a/server/src/api/User/shared/User.graphql b/server/src/api/User/shared/User.graphql
index 1b00301..6072fe4 100644
--- a/server/src/api/User/shared/User.graphql
+++ b/server/src/api/User/shared/User.graphql
@@ -16,6 +16,7 @@ type User {
 enum UserRole {
     ADMIN
     HOST
-    BOOKER
+    GUEST
+    # 비회원 => name, phoneNumber, password, email, createdAt, updatedAt 데이터 만을 가짐
     GHOST
 }
\ No newline at end of file
diff --git a/server/src/dtos/DateRange.class.ts b/server/src/dtos/DateRange.class.ts
new file mode 100644
index 0000000..c05bc2b
--- /dev/null
+++ b/server/src/dtos/DateRange.class.ts
@@ -0,0 +1,280 @@
+import { DateRange as DR } from "../types/graph";
+import { compareOption, Interval, Period } from "../types/types";
+
+interface DateRangeInterface {
+    setDate(dateRange: Period, option: compareOption): void;
+    getStartDate(): Date | undefined;
+    getEndDate(): Date | undefined;
+    getHashCode(): number;
+    compareDate(date: Date): string;
+    isOverlap(dateRange: DateRange): boolean;
+    interval(date: Date, target: "start" | "end"): Interval;
+    getParams(): object;
+}
+enum DateIncludeStatus {
+    FUTURE = "FUTURE",
+    INCLUDE = "INCLUDE",
+    PAST = "PAST"
+}
+
+const ONE_MINUTE = 1000 * 60;
+const ONE_HOUR = ONE_MINUTE * 60;
+const ONE_DAY = ONE_HOUR * 24;
+
+class DateRange implements DateRangeInterface {
+    private startDate: Date | undefined;
+    private endDate: Date | undefined;
+    private hashCode: number;
+    private option: compareOption = {
+        compareScope: "date",
+        ignoreYear: false
+    };
+
+    constructor(dateRange: Period, option?: compareOption) {
+        console.log({
+            dateRange
+        });
+
+        this.setDate(dateRange, option);
+    }
+
+    public getParams(): DR {
+        return {
+            hashCode: this.hashCode,
+            startDate: this.startDate && this.startDate.getTime(),
+            endDate: this.endDate && this.endDate.getTime()
+        };
+    }
+
+    /**
+     * 
+     * @param dateRange 비교할 대상
+     */
+    isOverlap(dateRange: DateRange): boolean {
+        const startDateIsOverlap =
+            dateRange.startDate && this.compareDate(dateRange.startDate);
+        const endDateIsOverlap =
+            dateRange.endDate && this.compareDate(dateRange.endDate);
+        if (
+            startDateIsOverlap === DateIncludeStatus.FUTURE ||
+            endDateIsOverlap === DateIncludeStatus.PAST
+        ) {
+            return false;
+        } else if (!startDateIsOverlap && !endDateIsOverlap) {
+            throw new Error("Both Values are 'undefined'");
+        }
+        return true;
+    }
+
+    /**
+     * -1, 0, 1 리턴함.
+     * 언제나 DateRange 를 기준으로 비교한다.
+     * DateRange를 기준으로 date가 FUTURE, INCLUDE, PAST 중 어디에 위치하여있는지 출력함
+     * @param date 비교할 날짜
+     */
+    compareDate(date: Date): string {
+        let startTime = this.startDate && this.startDate.getTime();
+        let endTime = this.endDate && this.endDate.getTime();
+        const objDate = this.getScopeDate(date);
+
+        if (this.option.compareScope === "date") {
+            if (startTime) {
+                startTime = startTime - (startTime % ONE_DAY);
+            }
+            if (endTime) {
+                endTime = endTime - (endTime % ONE_DAY);
+            }
+        }
+
+        const laterThenStartTime: boolean | undefined = this.compareIsTrue(
+            this.startDate,
+            objDate
+        );
+
+        const earlierThenEndTime: boolean | undefined = this.compareIsTrue(
+            objDate,
+            this.endDate
+        );
+
+        console.log({
+            laterThenStartTime,
+            earlierThenEndTime
+        });
+
+        if (laterThenStartTime && earlierThenEndTime) {
+            return DateIncludeStatus.INCLUDE;
+        } else if (
+            (earlierThenEndTime === undefined && laterThenStartTime) ||
+            (laterThenStartTime === undefined && earlierThenEndTime)
+        ) {
+            return DateIncludeStatus.INCLUDE;
+        } else if (laterThenStartTime === false) {
+            return DateIncludeStatus.FUTURE;
+        } else if (earlierThenEndTime === false) {
+            return DateIncludeStatus.PAST;
+        } else {
+            throw new Error("Invalid Start and End Date");
+        }
+    }
+
+    /**
+     * Interval을 리턴함.
+     * date > compareTarget => -
+     * date < compareTarget => +
+     * @param date 비교할 대상 날짜
+     * @param compareTarget startDate, endDate 둘 중 어느것과 비교할지 선택
+     */
+    public interval(
+        date: Date,
+        compareTarget: "start" | "end" = "start"
+    ): Interval {
+        const target =
+            compareTarget === "start" ? this.startDate : this.endDate;
+        const result = {
+            date: 0,
+            hour: 0,
+            minute: 0,
+            year: 0,
+            time: 0
+        };
+        if (target) {
+            // 현재 타임 스코프에 맞는 date를 구한다.
+            const objDate = this.getScopeDate(date);
+            const intervalTime = target.getTime() - objDate.getTime();
+            result.time = intervalTime;
+            result.hour = Math.floor(intervalTime / ONE_HOUR);
+            result.minute = Math.floor(intervalTime / ONE_MINUTE);
+            result.date = Math.floor(intervalTime / ONE_DAY);
+            result.date = Math.floor(intervalTime / (ONE_DAY * 365));
+        }
+        return result;
+    }
+
+    public getHashCode(): number {
+        return this.hashCode;
+    }
+
+    public getStartDate(): Date | undefined {
+        return this.startDate;
+    }
+
+    public getEndDate(): Date | undefined {
+        return this.endDate;
+    }
+
+    /**
+     * 필드의 startDate, endDate 변수 할당을 위한 함수
+     * @param param0 startDate, endDate
+     * @param option compareOption 참조
+     */
+    public setDate(
+        { startDate, endDate }: Period,
+        option?: compareOption
+    ): void {
+        const start = (startDate && new Date(startDate)) || this.startDate;
+        const end = (endDate && new Date(endDate)) || this.endDate;
+        if (start) {
+            start.setTime(this.getScopeDate(start).getTime());
+        }
+        if (end) {
+            end.setTime(this.getScopeDate(end).getTime());
+        }
+        const isValid = this.isValid({ startDate: start, endDate: end });
+        if (isValid) {
+            this.startDate = start;
+            this.endDate = end;
+        } else {
+            this.endDate = start;
+            this.startDate = end;
+        }
+        if (option) {
+            this.option = option;
+        }
+        this.setHashCode();
+    }
+
+    /**
+     * startDate, endDate 를 16진법으로 바꾼 뒤 this.hashCode 변수에 값을 할당함.
+     */
+    private setHashCode(): void {
+        // 16진법으로 출력하여 이어 붙이면 될듯하다
+        // startDate, endDate 중 undefined 변수가 있다면 0으로 바꿈
+        const startHash = this.makeDateToHex(
+            this.startDate,
+            this.option.compareScope || "date"
+        );
+        const endHash = this.makeDateToHex(
+            this.endDate,
+            this.option.compareScope || "date"
+        );
+
+        this.hashCode = parseInt(startHash + endHash, 16);
+    }
+
+    /**
+     * 날짜를 16진법 숫자로 표시해줌
+     * @param date 날짜 객체
+     * @param scope date, time 둘중 하나
+     */
+    private makeDateToHex(
+        date: Date | undefined,
+        scope: "date" | "time"
+    ): string {
+        // 4~5자리 16진수
+        const scopeUnit: number = scope === "date" ? ONE_DAY : ONE_MINUTE;
+        return date
+            ? Math.floor(new Date(date).getTime() / scopeUnit).toString(16)
+            : "0";
+    }
+
+    /**
+     * startDate, endDate 둘다 undefined 일때 에러남...
+     * @param param0 startDate, endDate를 받음...
+     */
+    private isValid({ startDate, endDate }: Period): boolean {
+        if (startDate && endDate) {
+            // start, end 둘 다 값이 있는 경우
+            if (startDate.getTime() <= endDate.getTime()) {
+                // start.getTime() <= end.getTime() 인 경우 => true
+                return true;
+            } // start.getTime() > end.getTime() 인 경우 => false
+            return false;
+        } else if (startDate || endDate) {
+            // start, end 둘 중 하나라도 값이 있는 경우 => true
+            return true;
+        } else {
+            // start, end 둘 다 undefined 인 경우 => false
+            throw new Error("StartDate and EndDate are Undefined");
+        }
+    }
+
+    private compareIsTrue(
+        early: Date | undefined,
+        late: Date | undefined
+    ): boolean | undefined {
+        if (early && late) {
+            return early.getTime() <= late.getTime();
+        } else {
+            return undefined;
+        }
+    }
+
+    private getScopeDate(date: Date): Date {
+        if (date) {
+            const result = date;
+            switch (this.option.compareScope) {
+                case "date":
+                    result.setHours(0);
+                    result.setMinutes(0);
+                case "time":
+                    result.setSeconds(0);
+                    result.setMilliseconds(0);
+                default:
+                    break;
+            }
+            return result;
+        }
+        return date;
+    }
+}
+export default DateRange;
diff --git a/server/src/dtos/DisableRange.class.ts b/server/src/dtos/DisableRange.class.ts
new file mode 100644
index 0000000..e704c01
--- /dev/null
+++ b/server/src/dtos/DisableRange.class.ts
@@ -0,0 +1,19 @@
+import { DisableRange as DR } from "../types/graph";
+import { compareOption, PeriodWithDescription } from "../types/types";
+import DateRange from "./DateRange.class";
+
+class DisableRange extends DateRange {
+    public description?: string | null;
+    constructor(period: PeriodWithDescription, option?: compareOption) {
+        super(period, option);
+        this.description = period.description;
+    }
+    public getParams(): DR {
+        return {
+            ...super.getParams(), 
+            description: this.description || null
+        }
+    }
+}
+
+export default DisableRange;
diff --git a/server/src/models/House.ts b/server/src/models/House.ts
index 483a64b..07bf754 100644
--- a/server/src/models/House.ts
+++ b/server/src/models/House.ts
@@ -1,6 +1,7 @@
 import { Types } from "mongoose";
-import { prop, Typegoose } from "typegoose";
+import { prop, Ref, Typegoose } from "typegoose";
 import { HouseType, Location, TermsOfBooking } from "../types/graph";
+import { ProductSchema } from "./Product";
 
 export enum Type {
     GUEST_HOUSE = "GUEST_HOUSE",
@@ -11,6 +12,9 @@ export enum Type {
     YOUTH_HOSTEL = "YOUTH_HOSTEL"
 }
 export class HouseSchema extends Typegoose {
+    @prop({ ref: ProductSchema, required: true })
+    product: Ref<ProductSchema>;
+
     @prop({ required: true })
     name: string;
 
diff --git a/server/src/models/Merge.ts b/server/src/models/Merge.ts
deleted file mode 100644
index 8858672..0000000
--- a/server/src/models/Merge.ts
+++ /dev/null
@@ -1,116 +0,0 @@
-import { ObjectId } from "bson";
-import { Types } from "mongoose";
-import { InstanceType } from "typegoose";
-import { House, Room, RoomType, User } from "../types/graph";
-import { HouseModel, HouseSchema } from "./House";
-import { RoomSchema } from "./Room";
-import { RoomTypeModel, RoomTypeSchema } from "./RoomType";
-import { UserModel, UserSchema } from "./User";
-
-export const extractUser = async (
-    user: InstanceType<UserSchema>
-): Promise<User> => {
-    const extractResult: any = {
-        ...user
-    };
-    return {
-        ...extractResult._doc,
-        password: null,
-        houses: await extractHouses.bind(extractHouses, user.houses)
-    };
-};
-
-export const extractHouse = async (
-    house: InstanceType<HouseSchema>
-): Promise<House> => {
-    try {
-        const extracted: any = {
-            ...house
-        };
-        return {
-            ...extracted._doc,
-            user: await extractUser.bind(
-                extractUser,
-                await UserModel.findById(house.user)
-            )
-        };
-    } catch (error) {
-        throw error;
-    }
-};
-
-export const extractHouses = async (
-    houseIds: Types.ObjectId[]
-): Promise<Array<Promise<House>>> => {
-    try {
-        const houses = await HouseModel.find({ _id: { $in: houseIds } });
-        return houses.map(async house => {
-            return await extractHouse(house);
-        });
-    } catch (error) {
-        throw error;
-    }
-};
-
-export const extractRoomType = async (
-    roomType: InstanceType<RoomTypeSchema> | string
-): Promise<RoomType> => {
-    let extractResult: any;
-    if (typeof(roomType) === 'string') {
-        extractResult = {
-            ...(await RoomTypeModel.findById({ _id: new ObjectId(roomType) }))
-        };
-    } else {
-        extractResult = {
-            ...roomType
-        };
-    }
-    const house = await HouseModel.findById(extractResult._doc.house);
-    const result = {
-        ...extractResult._doc
-    };
-
-    if (house) {
-        result.house = await extractHouse(house);
-    }
-    return result;
-};
-
-export const extractRoomTypes = async (
-    houseId: ObjectId
-): Promise<RoomType[]> => {
-    const house = await HouseModel.findOne({ _id: houseId }, { roomTypes: 1 });
-    console.log({
-        extractRoomTypes: house
-    });
-
-    const result: RoomType[] = [];
-    if (house) {
-        await house.roomTypes.forEach(async roomTypeId => {
-            const temp = await RoomTypeModel.findById(roomTypeId);
-            if (temp) {
-                result.push(await extractRoomType(temp));
-            }
-        });
-    }
-
-    return result;
-};
-
-export const extractRoom = async (
-    room: InstanceType<RoomSchema>
-): Promise<Room> => {
-    const extractResult: any = {
-        ...room
-    };
-    const roomType = await RoomTypeModel.findById(extractResult._doc.roomType);
-    if (roomType) {
-        return {
-            ...extractResult._doc,
-            roomType: await extractRoomType(roomType),
-            disableRanges: extractResult._doc.disableRanges || []
-        };
-    } else {
-        throw new Error("RoomType is Null...");
-    }
-};
diff --git a/server/src/models/Room.ts b/server/src/models/Room.ts
index a37563b..3f3bf92 100644
--- a/server/src/models/Room.ts
+++ b/server/src/models/Room.ts
@@ -1,7 +1,13 @@
 import { ObjectId } from "bson";
 import { Types } from "mongoose";
 import { pre, prop, Typegoose } from "typegoose";
-import { DisableRange } from "../types/graph";
+
+interface DisableRange {
+    hashCode: number;
+    startDate?: Date;
+    endDate?: Date;
+    description?: string | null;
+}
 
 @pre<RoomSchema>("save", async function(next) {
     try {
diff --git a/server/src/models/RoomType.ts b/server/src/models/RoomType.ts
index d0e78cb..e5451ec 100644
--- a/server/src/models/RoomType.ts
+++ b/server/src/models/RoomType.ts
@@ -44,7 +44,7 @@ export class RoomTypeSchema extends Typegoose {
     @prop({
         required: [
             function(this: RoomTypeSchema) {
-                return 1 < this.peopleCount;
+                return 0 < this.peopleCount;
             },
             "Too Few peopleCount..."
         ],
diff --git a/server/src/models/Season.ts b/server/src/models/Season.ts
new file mode 100644
index 0000000..def03be
--- /dev/null
+++ b/server/src/models/Season.ts
@@ -0,0 +1,55 @@
+import { ObjectId } from "bson";
+import { Types } from "mongoose";
+import { index, pre, prop, Typegoose } from "typegoose";
+import { DateRange } from "../types/graph";
+
+@index({ house: 1 })
+@index({ priority: -1 })
+@pre<SeasonSchema>("save", async function(next) {
+    try {
+        if (this.priority <= 0 || !this.priority) {
+            const test = await SeasonModel.findOne({
+                house: new ObjectId(this.house)
+            }).sort({ priority: -1 });
+            if (test) {
+                this.priority = test.priority + 1;
+            }
+        }
+        this.house = new ObjectId(this.house);
+    } catch (error) {
+        throw error;
+    }
+    next();
+})
+export class SeasonSchema extends Typegoose {
+    @prop({ required: true })
+    name: string;
+
+    @prop({ required: true })
+    dateRange: DateRange;
+
+    @prop({ default: 0, min: 0 })
+    priority: number;
+
+    @prop()
+    color: string | null;
+
+    @prop()
+    description: string | null;
+
+    @prop({ required: true })
+    house: Types.ObjectId;
+
+    @prop()
+    createdAt: Date;
+
+    @prop()
+    updatedAt: Date;
+}
+
+export const SeasonModel = new SeasonSchema().getModelForClass(SeasonSchema, {
+    schemaOptions: {
+        timestamps: true,
+        collection: "Seasons"
+    }
+});
diff --git a/server/src/models/User.ts b/server/src/models/User.ts
index f414253..4c1f269 100644
--- a/server/src/models/User.ts
+++ b/server/src/models/User.ts
@@ -17,7 +17,7 @@ export enum UserRole {
 const BCRYPT_ROUNDS = 10;
 
 export class UserSchema extends Typegoose {
-    @prop({ required: [true, `firstName is missing`] })
+    @prop({ required: [true, `Name is missing`] })
     name: string;
 
     @prop()
diff --git a/server/src/models/merge/Merge.ts b/server/src/models/merge/Merge.ts
new file mode 100644
index 0000000..ed38ba5
--- /dev/null
+++ b/server/src/models/merge/Merge.ts
@@ -0,0 +1,249 @@
+import { ObjectId } from "bson";
+import { Types } from "mongoose";
+import { InstanceType } from "typegoose";
+import DateRange from "../../dtos/DateRange.class";
+import {
+    House,
+    Product,
+    ProductType,
+    Room,
+    RoomType,
+    Season,
+    User,
+} from "../../types/graph";
+import { HouseModel, HouseSchema } from "../House";
+import { ProductSchema } from "../Product";
+import { ProductTypeSchema } from "../ProductType";
+import { RoomModel, RoomSchema } from "../Room";
+import { RoomTypeModel, RoomTypeSchema } from "../RoomType";
+import { SeasonModel, SeasonSchema } from "../Season";
+import { UserModel, UserSchema } from "../User";
+
+/*
+    - extract로 시작하느 함수들은 InstanceType<T> 를 변수로 받는 async 함수
+    - transform 으로 시작하는 함수들은 ObjectId 를 변수로 받아 함수 안에서 DB에 접속하여 결과값을 출력하는 async 함수
+*/
+export const extractUser = async (
+    user: InstanceType<UserSchema>
+): Promise<User> => {
+    const extractResult: any = {
+        ...user
+    };
+    return {
+        ...extractResult._doc,
+        password: null,
+        houses: await extractHouses.bind(extractHouses, user.houses)
+    };
+};
+
+export const transformUser = async (
+    userId: ObjectId | string
+): Promise<User | null> => {
+    const user: InstanceType<UserSchema> | null = await UserModel.findById(
+        userId
+    );
+    if (user) {
+        return await extractUser(user);
+    } else {
+        return null;
+    }
+};
+
+export const extractHouse = async (
+    house: InstanceType<HouseSchema>
+): Promise<House> => {
+    try {
+        const extracted: any = {
+            ...house
+        };
+        return {
+            ...extracted._doc,
+            user: await extractUser.bind(
+                extractUser,
+                await UserModel.findById(house.user)
+            )
+        };
+    } catch (error) {
+        throw error;
+    }
+};
+
+export const transformHouse = async (
+    houseId: ObjectId | string
+): Promise<House | null> => {
+    const house: InstanceType<HouseSchema> | null = await HouseModel.findById(
+        houseId
+    );
+    if (house) {
+        return await extractHouse(house);
+    } else {
+        return null;
+    }
+};
+
+export const extractHouses = async (
+    houseIds: Types.ObjectId[]
+): Promise<Array<Promise<House>>> => {
+    try {
+        const houses = await HouseModel.find({ _id: { $in: houseIds } });
+        return houses.map(async house => {
+            return await extractHouse(house);
+        });
+    } catch (error) {
+        throw error;
+    }
+};
+
+export const extractRoomType = async (
+    roomType: InstanceType<RoomTypeSchema> | string
+): Promise<RoomType> => {
+    let extractResult: any;
+    if (typeof roomType === "string") {
+        extractResult = {
+            ...(await RoomTypeModel.findById(roomType))
+        };
+    } else {
+        extractResult = {
+            ...roomType
+        };
+    }
+    const house = await HouseModel.findById(extractResult._doc.house);
+    const result = {
+        ...extractResult._doc,
+        rooms: await transformRooms.bind(
+            transformRooms,
+            extractResult._doc.rooms
+        )
+    };
+
+    if (house) {
+        result.house = await extractHouse(house);
+    }
+    return result;
+};
+
+export const transformRoomType = async (
+    roomTypeId: string | ObjectId
+): Promise<RoomType> => {
+    const roomTypeSchema: InstanceType<
+        RoomTypeSchema
+    > | null = await RoomTypeModel.findById(roomTypeId);
+    if (roomTypeSchema) {
+        return await extractRoomType(roomTypeSchema);
+    } else {
+        throw new Error("Unexist Id");
+    }
+};
+
+export const extractRoomTypes = async (
+    roomTypeIds: ObjectId[]
+): Promise<RoomType[]> => {
+    try {
+        const results: RoomType[] = await Promise.all(
+            roomTypeIds.map(
+                async (roomTypeId): Promise<RoomType> => {
+                    return await transformRoomType(roomTypeId);
+                }
+            )
+        );
+        return results;
+    } catch (error) {
+        return [];
+    }
+};
+
+export const transformRooms = async (roomIds: ObjectId[]): Promise<Room[]> => {
+    try {
+        const result: Room[] = await Promise.all(
+            roomIds.map(
+                async (roomId): Promise<Room> => {
+                    return await transformRoom(roomId);
+                }
+            )
+        );
+        return result;
+    } catch (error) {
+        return [];
+    }
+};
+
+export const transformRoom = async (
+    roomId: ObjectId | string
+): Promise<Room> => {
+    const roomSchema: InstanceType<
+        RoomSchema
+    > | null = await RoomModel.findById(roomId);
+    if (roomSchema) {
+        return await extractRoom(roomSchema);
+    } else {
+        throw new Error("Unexist Id");
+    }
+};
+
+export const extractRoom = async (
+    room: InstanceType<RoomSchema>
+): Promise<Room> => {
+    const extractResult: any = {
+        ...room
+    };
+    const roomType = await RoomTypeModel.findById(extractResult._doc.roomType);
+    if (roomType) {
+        return {
+            ...extractResult._doc,
+            roomType: await extractRoomType.bind(extractRoomType, roomType),
+            disableRanges: extractResult._doc.disableRanges || []
+        };
+    } else {
+        throw new Error("RoomType is Null...");
+    }
+};
+
+export const extractSeason = async (
+    season: InstanceType<SeasonSchema>
+): Promise<Season> => {
+    const extractResult: any = { ...season };
+
+    console.log({
+        extractResult
+    });
+
+    return {
+        ...extractResult._doc,
+        house: await transformHouse.bind(
+            transformHouse,
+            extractResult._doc.house
+        ),
+        dateRange: new DateRange(extractResult._doc.dateRange).getParams()
+    };
+};
+
+export const transformSeason = async (
+    seasonId: ObjectId
+): Promise<Season | null> => {
+    const season: InstanceType<
+        SeasonSchema
+    > | null = await SeasonModel.findById(seasonId);
+    if (season) {
+        return await extractSeason(season);
+    } else {
+        return null;
+    }
+};
+
+export const extractProductType = (
+    productType: InstanceType<ProductTypeSchema>
+): ProductType => {
+    const result: any = { ...productType };
+    return {
+        ...result._doc
+    };
+};
+
+export const extractProduct = (
+    product: InstanceType<ProductSchema>
+): Product => {
+    const result: any = { ...product };
+    return {
+        ...result._doc
+    };
+};
diff --git a/server/src/queries/queries.ts b/server/src/queries/queries.ts
new file mode 100644
index 0000000..3d8d663
--- /dev/null
+++ b/server/src/queries/queries.ts
@@ -0,0 +1,74 @@
+interface DuplicateRangeParams {
+    startDate: number;
+    endDate: number;
+    className?: "disableRanges" | "dateRanges";
+}
+
+export const dateRangeDuplicateCheckQuery = ({
+    startDate,
+    endDate,
+    className = "dateRanges"
+}: DuplicateRangeParams): any => {
+    return {
+        [className]: {
+            $elemMatch: {
+                $or: [
+                    {
+                        $or: [
+                            {
+                                startDate: {
+                                    $gte: startDate || 0,
+                                    $lt: endDate || startDate * 3
+                                }
+                            },
+                            {
+                                endDate: {
+                                    $gt: startDate || 0,
+                                    $lte: endDate || startDate * 3
+                                }
+                            }
+                        ]
+                    },
+                    {
+                        $and: [
+                            {
+                                startDate: {
+                                    $lte: startDate || 0
+                                }
+                            },
+                            {
+                                endDate: {
+                                    $gte: endDate || startDate * 3
+                                }
+                            }
+                        ]
+                    }
+                ]
+            }
+        }
+    };
+};
+
+export interface SelectNumberRangeReturn {
+    condition: any;
+    increment: number;
+}
+
+export const selectNumberRange = (
+    origin: number,
+    target: number
+): SelectNumberRangeReturn => {
+    // TODO: 여기서부터 하면 될듯하다 ㅎㅎ
+    let increment = 1;
+    let condition: any;
+    if (origin > target) {
+        increment = -1;
+        condition = { $gt: target, $lte: origin };
+    } else {
+        condition = { $gte: origin, $lt: target };
+    }
+    return {
+        condition,
+        increment
+    };
+};
diff --git a/server/src/utils/DateRange.class.ts b/server/src/utils/DateRange.class.ts
deleted file mode 100644
index cb0ddda..0000000
--- a/server/src/utils/DateRange.class.ts
+++ /dev/null
@@ -1,100 +0,0 @@
-import { CompareOption, Period } from "../types/types";
-
-interface DateRangeInterface {
-    setDate(dateRange: Period): void;
-    getStartDate(): Date | undefined;
-    getEndDate(): Date | undefined;
-    includeDate(date: Date, option: CompareOption): number;
-}
-enum DateIncludeStatus {
-    FUTURE = -1,
-    INCLUDE = 0,
-    PAST = 1
-}
-
-const ONE_DAY = 1000 * 60 * 60 * 24;
-
-class DateRange implements DateRangeInterface {
-    private startDate: Date | undefined;
-    private endDate: Date | undefined;
-
-    constructor(dateRange: Period) {
-        this.setDate(dateRange);
-    }
-
-    includeDate(date: Date, { compareScope = "date" }: CompareOption): number {
-        const time = date.getTime();
-        let startTime = this.startDate && this.startDate.getTime();
-        let endTime = this.endDate && this.endDate.getTime();
-        if (compareScope === "date") {
-            if (startTime) {
-                startTime = startTime - (startTime % ONE_DAY);
-            }
-            if (endTime) {
-                endTime = endTime - (endTime % ONE_DAY);
-            }
-        }
-        const laterThenStartTime: boolean | undefined =
-            startTime === 0 && undefined && startTime < time;
-        const earlierThenEndTime: boolean | undefined =
-            endTime === 0 && undefined && time < endTime;
-        console.log({
-            st: laterThenStartTime,
-            ed: earlierThenEndTime
-        });
-
-        if (
-            (laterThenStartTime && earlierThenEndTime) ||
-            (earlierThenEndTime === undefined && laterThenStartTime) ||
-            (laterThenStartTime === undefined && earlierThenEndTime)
-        ) {
-            return DateIncludeStatus.INCLUDE;
-        } else if (laterThenStartTime === false) {
-            return DateIncludeStatus.FUTURE;
-        } else if (earlierThenEndTime === false) {
-            return DateIncludeStatus.PAST;
-        } else {
-            throw new Error("Invalid Start and End Date");
-        }
-    }
-
-    public getStartDate(): Date | undefined {
-        return this.startDate;
-    }
-
-    public getEndDate(): Date | undefined {
-        return this.endDate;
-    }
-
-    public setDate({ startDate, endDate }: Period): void {
-        const start = startDate || this.startDate;
-        const end = endDate || this.endDate;
-        const isValid = this.isValid({ startDate: start, endDate: end });
-
-        if (isValid) {
-            this.startDate = start;
-            this.endDate = end;
-        } else {
-            this.endDate = start;
-            this.startDate = end;
-        }
-    }
-
-    private isValid({ startDate, endDate }: Period): boolean {
-        if (startDate && endDate) {
-            // start, end 둘 다 값이 있는 경우
-            if (startDate.getTime() >= endDate.getTime()) {
-                // start.getTime() <= end.getTime() 인 경우 => true
-                return true;
-            } // start.getTime() > end.getTime() 인 경우 => false
-            return false;
-        } else if (startDate || endDate) {
-            // start, end 둘 중 하나라도 값이 있는 경우 => true
-            return true;
-        } else {
-            // start, end 둘 다 null 인 경우 => false
-            throw new Error("StartDate and EndDate are Undefined");
-        }
-    }
-}
-export default DateRange;
diff --git a/server/src/utils/DisableRange.class.ts b/server/src/utils/DisableRange.class.ts
deleted file mode 100644
index 62a47a4..0000000
--- a/server/src/utils/DisableRange.class.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-import { Period } from "../types/types";
-import DateRange from "./DateRange.class";
-
-class DisableRange extends DateRange {
-    public description?: string;
-    constructor(period: Period, description?: string) {
-        super(period);
-        this.description = description;
-    }
-}
-
-export default DisableRange;
diff --git a/server/tslint.json b/server/tslint.json
index 21130e0..22e7552 100644
--- a/server/tslint.json
+++ b/server/tslint.json
@@ -6,7 +6,8 @@
     "linterOptions": {
         "exclude": [
             "config/**/*.js",
-            "node_modules/**/*."
+            "node_modules/**/*.",
+            "../client/*"
         ]
     },
     "rules": {
-- 
2.10.2.windows.1

