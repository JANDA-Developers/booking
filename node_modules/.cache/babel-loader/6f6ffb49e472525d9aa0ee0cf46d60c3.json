{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _Items = require('./items/Items');\n\nvar _Items2 = _interopRequireDefault(_Items);\n\nvar _InfoLabel = require('./layout/InfoLabel');\n\nvar _InfoLabel2 = _interopRequireDefault(_InfoLabel);\n\nvar _Sidebar = require('./layout/Sidebar');\n\nvar _Sidebar2 = _interopRequireDefault(_Sidebar);\n\nvar _Columns = require('./columns/Columns');\n\nvar _Columns2 = _interopRequireDefault(_Columns);\n\nvar _GroupRows = require('./row/GroupRows');\n\nvar _GroupRows2 = _interopRequireDefault(_GroupRows);\n\nvar _ScrollElement = require('./scroll/ScrollElement');\n\nvar _ScrollElement2 = _interopRequireDefault(_ScrollElement);\n\nvar _MarkerCanvas = require('./markers/MarkerCanvas');\n\nvar _MarkerCanvas2 = _interopRequireDefault(_MarkerCanvas);\n\nvar _window = require('../resize-detector/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _calendar = require('./utility/calendar');\n\nvar _generic = require('./utility/generic');\n\nvar _defaultConfig = require('./default-config');\n\nvar _TimelineStateContext = require('./timeline/TimelineStateContext');\n\nvar _TimelineMarkersContext = require('./markers/TimelineMarkersContext');\n\nvar _HeadersContext = require('./headers/HeadersContext');\n\nvar _TimelineHeaders = require('./headers/TimelineHeaders');\n\nvar _TimelineHeaders2 = _interopRequireDefault(_TimelineHeaders);\n\nvar _DateHeader = require('./headers/DateHeader');\n\nvar _DateHeader2 = _interopRequireDefault(_DateHeader);\n\nvar _SidebarHeader = require('./headers/SidebarHeader');\n\nvar _SidebarHeader2 = _interopRequireDefault(_SidebarHeader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ReactCalendarTimeline = function (_Component) {\n  _inherits(ReactCalendarTimeline, _Component);\n\n  _createClass(ReactCalendarTimeline, [{\n    key: 'getChildContext',\n    value: function getChildContext() {\n      var _this2 = this;\n\n      return {\n        getTimelineContext: function getTimelineContext() {\n          return _this2.getTimelineContext();\n        }\n      };\n    }\n  }]);\n\n  function ReactCalendarTimeline(props) {\n    _classCallCheck(this, ReactCalendarTimeline);\n\n    var _this = _possibleConstructorReturn(this, (ReactCalendarTimeline.__proto__ || Object.getPrototypeOf(ReactCalendarTimeline)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var visibleTimeStart = null;\n    var visibleTimeEnd = null;\n\n    if (_this.props.defaultTimeStart && _this.props.defaultTimeEnd) {\n      visibleTimeStart = _this.props.defaultTimeStart.valueOf();\n      visibleTimeEnd = _this.props.defaultTimeEnd.valueOf();\n    } else if (_this.props.visibleTimeStart && _this.props.visibleTimeEnd) {\n      visibleTimeStart = _this.props.visibleTimeStart;\n      visibleTimeEnd = _this.props.visibleTimeEnd;\n    } else {\n      //throwing an error because neither default or visible time props provided\n      throw new Error('You must provide either \"defaultTimeStart\" and \"defaultTimeEnd\" or \"visibleTimeStart\" and \"visibleTimeEnd\" to initialize the Timeline');\n    }\n\n    var _getCanvasBoundariesF = (0, _calendar.getCanvasBoundariesFromVisibleTime)(visibleTimeStart, visibleTimeEnd),\n        _getCanvasBoundariesF2 = _slicedToArray(_getCanvasBoundariesF, 2),\n        canvasTimeStart = _getCanvasBoundariesF2[0],\n        canvasTimeEnd = _getCanvasBoundariesF2[1];\n\n    _this.state = {\n      width: 1000,\n      visibleTimeStart: visibleTimeStart,\n      visibleTimeEnd: visibleTimeEnd,\n      canvasTimeStart: canvasTimeStart,\n      canvasTimeEnd: canvasTimeEnd,\n      selectedItem: null,\n      dragTime: null,\n      dragGroupTitle: null,\n      resizeTime: null,\n      resizingItem: null,\n      resizingEdge: null\n    };\n    var canvasWidth = (0, _calendar.getCanvasWidth)(_this.state.width);\n\n    var _stackTimelineItems = (0, _calendar.stackTimelineItems)(props.items, props.groups, canvasWidth, _this.state.canvasTimeStart, _this.state.canvasTimeEnd, props.keys, props.lineHeight, props.itemHeightRatio, props.stackItems, _this.state.draggingItem, _this.state.resizingItem, _this.state.dragTime, _this.state.resizingEdge, _this.state.resizeTime, _this.state.newGroupOrder),\n        dimensionItems = _stackTimelineItems.dimensionItems,\n        height = _stackTimelineItems.height,\n        groupHeights = _stackTimelineItems.groupHeights,\n        groupTops = _stackTimelineItems.groupTops;\n    /* eslint-disable react/no-direct-mutation-state */\n\n\n    _this.state.dimensionItems = dimensionItems;\n    _this.state.height = height;\n    _this.state.groupHeights = groupHeights;\n    _this.state.groupTops = groupTops;\n    /* eslint-enable */\n\n    return _this;\n  }\n\n  _createClass(ReactCalendarTimeline, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.resize(this.props);\n\n      if (this.props.resizeDetector && this.props.resizeDetector.addListener) {\n        this.props.resizeDetector.addListener(this);\n      }\n\n      _window2.default.addListener(this);\n\n      this.lastTouchDistance = null;\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.props.resizeDetector && this.props.resizeDetector.addListener) {\n        this.props.resizeDetector.removeListener(this);\n      }\n\n      _window2.default.removeListener(this);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var newZoom = this.state.visibleTimeEnd - this.state.visibleTimeStart;\n      var oldZoom = prevState.visibleTimeEnd - prevState.visibleTimeStart; // are we changing zoom? Report it!\n\n      if (this.props.onZoom && newZoom !== oldZoom) {\n        this.props.onZoom(this.getTimelineContext());\n      } // The bounds have changed? Report it!\n\n\n      if (this.props.onBoundsChange && this.state.canvasTimeStart !== prevState.canvasTimeStart) {\n        this.props.onBoundsChange(this.state.canvasTimeStart, this.state.canvasTimeStart + newZoom * 3);\n      } // Check the scroll is correct\n\n\n      var scrollLeft = Math.round(this.state.width * (this.state.visibleTimeStart - this.state.canvasTimeStart) / newZoom);\n      var componentScrollLeft = Math.round(this.scrollComponent.scrollLeft);\n\n      if (componentScrollLeft !== scrollLeft) {\n        this.scrollComponent.scrollLeft = scrollLeft;\n        this.scrollHeaderRef.scrollLeft = scrollLeft;\n      }\n    } // called when the visible time changes\n    // TODO: this is very similar to timeFromItemEvent, aside from which element to get offsets\n    // from.  Look to consolidate the logic for determining coordinate to time\n    // as well as generalizing how we get time from click on the canvas\n\n  }, {\n    key: 'columns',\n    value: function columns(canvasTimeStart, canvasTimeEnd, canvasWidth, minUnit, timeSteps, height) {\n      return _react2.default.createElement(_Columns2.default, {\n        canvasTimeStart: canvasTimeStart,\n        canvasTimeEnd: canvasTimeEnd,\n        canvasWidth: canvasWidth,\n        lineCount: (0, _generic._length)(this.props.groups),\n        minUnit: minUnit,\n        timeSteps: timeSteps,\n        height: height,\n        verticalLineClassNamesForTime: this.props.verticalLineClassNamesForTime\n      });\n    }\n  }, {\n    key: 'rows',\n    value: function rows(canvasWidth, groupHeights, groups) {\n      return _react2.default.createElement(_GroupRows2.default, {\n        groups: groups,\n        canvasWidth: canvasWidth,\n        lineCount: (0, _generic._length)(this.props.groups),\n        groupHeights: groupHeights,\n        clickTolerance: this.props.clickTolerance,\n        onRowClick: this.handleRowClick,\n        onRowDoubleClick: this.handleRowDoubleClick,\n        horizontalLineClassNamesForGroup: this.props.horizontalLineClassNamesForGroup,\n        onRowContextClick: this.handleScrollContextMenu\n      });\n    }\n  }, {\n    key: 'items',\n    value: function items(canvasTimeStart, zoom, canvasTimeEnd, canvasWidth, minUnit, dimensionItems, groupHeights, groupTops) {\n      return _react2.default.createElement(_Items2.default, {\n        canvasTimeStart: canvasTimeStart,\n        canvasTimeEnd: canvasTimeEnd,\n        canvasWidth: canvasWidth,\n        dimensionItems: dimensionItems,\n        groupTops: groupTops,\n        items: this.props.items,\n        groups: this.props.groups,\n        keys: this.props.keys,\n        selectedItem: this.state.selectedItem,\n        dragSnap: this.props.dragSnap,\n        minResizeWidth: this.props.minResizeWidth,\n        canChangeGroup: this.props.canChangeGroup,\n        canMove: this.props.canMove,\n        canResize: this.props.canResize,\n        useResizeHandle: this.props.useResizeHandle,\n        canSelect: this.props.canSelect,\n        moveResizeValidator: this.props.moveResizeValidator,\n        itemSelect: this.selectItem,\n        itemDrag: this.dragItem,\n        itemDrop: this.dropItem,\n        onItemDoubleClick: this.doubleClickItem,\n        onItemContextMenu: this.contextMenuClickItem,\n        itemResizing: this.resizingItem,\n        itemResized: this.resizedItem,\n        itemRenderer: this.props.itemRenderer,\n        selected: this.props.selected,\n        scrollRef: this.scrollComponent\n      });\n    }\n  }, {\n    key: 'infoLabel',\n    value: function infoLabel() {\n      var label = null;\n\n      if (this.state.dragTime) {\n        label = (0, _moment2.default)(this.state.dragTime).format('LLL') + ', \\n        ' + this.state.dragGroupTitle;\n      } else if (this.state.resizeTime) {\n        label = (0, _moment2.default)(this.state.resizeTime).format('LLL');\n      }\n\n      return label ? _react2.default.createElement(_InfoLabel2.default, {\n        label: label\n      }) : undefined;\n    }\n  }, {\n    key: 'sidebar',\n    value: function sidebar(height, groupHeights) {\n      var sidebarWidth = this.props.sidebarWidth;\n      return sidebarWidth && _react2.default.createElement(_Sidebar2.default, {\n        groups: this.props.groups,\n        groupRenderer: this.props.groupRenderer,\n        keys: this.props.keys,\n        width: sidebarWidth,\n        groupHeights: groupHeights,\n        height: height\n      });\n    }\n  }, {\n    key: 'rightSidebar',\n    value: function rightSidebar(height, groupHeights) {\n      var rightSidebarWidth = this.props.rightSidebarWidth;\n      return rightSidebarWidth && _react2.default.createElement(_Sidebar2.default, {\n        groups: this.props.groups,\n        keys: this.props.keys,\n        groupRenderer: this.props.groupRenderer,\n        isRightSidebar: true,\n        width: rightSidebarWidth,\n        groupHeights: groupHeights,\n        height: height\n      });\n    }\n  }, {\n    key: 'childrenWithProps',\n    value: function childrenWithProps(canvasTimeStart, canvasTimeEnd, canvasWidth, dimensionItems, groupHeights, groupTops, height, visibleTimeStart, visibleTimeEnd, minUnit, timeSteps) {\n      if (!this.props.children) {\n        return null;\n      } // convert to an array and remove the nulls\n\n\n      var childArray = Array.isArray(this.props.children) ? this.props.children.filter(function (c) {\n        return c;\n      }) : [this.props.children];\n      var childProps = {\n        canvasTimeStart: canvasTimeStart,\n        canvasTimeEnd: canvasTimeEnd,\n        canvasWidth: canvasWidth,\n        visibleTimeStart: visibleTimeStart,\n        visibleTimeEnd: visibleTimeEnd,\n        dimensionItems: dimensionItems,\n        items: this.props.items,\n        groups: this.props.groups,\n        keys: this.props.keys,\n        groupHeights: groupHeights,\n        groupTops: groupTops,\n        selected: this.state.selectedItem && !this.props.selected ? [this.state.selectedItem] : this.props.selected || [],\n        height: height,\n        minUnit: minUnit,\n        timeSteps: timeSteps\n      };\n      return _react2.default.Children.map(childArray, function (child) {\n        if (child.type !== _TimelineHeaders2.default) {\n          return _react2.default.cloneElement(child, childProps);\n        } else {\n          return null;\n        }\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          items = _props.items,\n          groups = _props.groups,\n          sidebarWidth = _props.sidebarWidth,\n          rightSidebarWidth = _props.rightSidebarWidth,\n          timeSteps = _props.timeSteps,\n          traditionalZoom = _props.traditionalZoom;\n      var _state = this.state,\n          draggingItem = _state.draggingItem,\n          resizingItem = _state.resizingItem,\n          width = _state.width,\n          visibleTimeStart = _state.visibleTimeStart,\n          visibleTimeEnd = _state.visibleTimeEnd,\n          canvasTimeStart = _state.canvasTimeStart,\n          canvasTimeEnd = _state.canvasTimeEnd;\n      var _state2 = this.state,\n          dimensionItems = _state2.dimensionItems,\n          height = _state2.height,\n          groupHeights = _state2.groupHeights,\n          groupTops = _state2.groupTops;\n      var zoom = visibleTimeEnd - visibleTimeStart;\n      var canvasWidth = (0, _calendar.getCanvasWidth)(width);\n      var minUnit = (0, _calendar.getMinUnit)(zoom, width, timeSteps);\n      var isInteractingWithItem = !!draggingItem || !!resizingItem;\n\n      if (isInteractingWithItem) {\n        var stackResults = (0, _calendar.stackTimelineItems)(items, groups, canvasWidth, this.state.canvasTimeStart, this.state.canvasTimeEnd, this.props.keys, this.props.lineHeight, this.props.itemHeightRatio, this.props.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);\n        dimensionItems = stackResults.dimensionItems;\n        height = stackResults.height;\n        groupHeights = stackResults.groupHeights;\n        groupTops = stackResults.groupTops;\n      }\n\n      var outerComponentStyle = {\n        height: height + 'px'\n      };\n      return _react2.default.createElement(_TimelineStateContext.TimelineStateProvider, {\n        visibleTimeStart: visibleTimeStart,\n        visibleTimeEnd: visibleTimeEnd,\n        canvasTimeStart: canvasTimeStart,\n        canvasTimeEnd: canvasTimeEnd,\n        canvasWidth: canvasWidth,\n        showPeriod: this.showPeriod,\n        timelineUnit: minUnit,\n        timelineWidth: this.state.width\n      }, _react2.default.createElement(_TimelineMarkersContext.TimelineMarkersProvider, null, _react2.default.createElement(_HeadersContext.TimelineHeadersProvider, {\n        registerScroll: this.handleHeaderRef,\n        timeSteps: timeSteps,\n        leftSidebarWidth: this.props.sidebarWidth,\n        rightSidebarWidth: this.props.rightSidebarWidth\n      }, _react2.default.createElement('div', {\n        style: this.props.style,\n        ref: function ref(el) {\n          return _this3.container = el;\n        },\n        className: 'react-calendar-timeline'\n      }, this.renderHeaders(), _react2.default.createElement('div', {\n        style: outerComponentStyle,\n        className: 'rct-outer'\n      }, sidebarWidth > 0 ? this.sidebar(height, groupHeights) : null, _react2.default.createElement(_ScrollElement2.default, {\n        scrollRef: this.getScrollElementRef,\n        width: width,\n        height: height,\n        onZoom: this.changeZoom,\n        onWheelZoom: this.handleWheelZoom,\n        traditionalZoom: traditionalZoom,\n        onScroll: this.onScroll,\n        isInteractingWithItem: isInteractingWithItem\n      }, _react2.default.createElement(_MarkerCanvas2.default, null, this.items(canvasTimeStart, zoom, canvasTimeEnd, canvasWidth, minUnit, dimensionItems, groupHeights, groupTops), this.columns(canvasTimeStart, canvasTimeEnd, canvasWidth, minUnit, timeSteps, height), this.rows(canvasWidth, groupHeights, groups), this.infoLabel(), this.childrenWithProps(canvasTimeStart, canvasTimeEnd, canvasWidth, dimensionItems, groupHeights, groupTops, height, visibleTimeStart, visibleTimeEnd, minUnit, timeSteps))), rightSidebarWidth > 0 ? this.rightSidebar(height, groupHeights) : null)))));\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var visibleTimeStart = nextProps.visibleTimeStart,\n          visibleTimeEnd = nextProps.visibleTimeEnd,\n          items = nextProps.items,\n          groups = nextProps.groups; // This is a gross hack pushing items and groups in to state only to allow\n      // For the forceUpdate check\n\n      var derivedState = {\n        items: items,\n        groups: groups // if the items or groups have changed we must re-render\n\n      };\n      var forceUpdate = items !== prevState.items || groups !== prevState.groups; // We are a controlled component\n\n      if (visibleTimeStart && visibleTimeEnd) {\n        // Get the new canvas position\n        Object.assign(derivedState, (0, _calendar.calculateScrollCanvas)(visibleTimeStart, visibleTimeEnd, forceUpdate, items, groups, nextProps, prevState));\n      } else if (forceUpdate) {\n        // Calculate new item stack position as canvas may have changed\n        var canvasWidth = (0, _calendar.getCanvasWidth)(prevState.width);\n        Object.assign(derivedState, (0, _calendar.stackTimelineItems)(items, groups, canvasWidth, prevState.canvasTimeStart, prevState.canvasTimeEnd, nextProps.keys, nextProps.lineHeight, nextProps.itemHeightRatio, nextProps.stackItems, prevState.draggingItem, prevState.resizingItem, prevState.dragTime, prevState.resizingEdge, prevState.resizeTime, prevState.newGroupOrder));\n      }\n\n      return derivedState;\n    }\n  }]);\n\n  return ReactCalendarTimeline;\n}(_react.Component);\n\nReactCalendarTimeline.propTypes = {\n  groups: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object]).isRequired,\n  items: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object]).isRequired,\n  sidebarWidth: _propTypes2.default.number,\n  rightSidebarWidth: _propTypes2.default.number,\n  dragSnap: _propTypes2.default.number,\n  minResizeWidth: _propTypes2.default.number,\n  stickyHeader: _propTypes2.default.bool,\n  lineHeight: _propTypes2.default.number,\n  itemHeightRatio: _propTypes2.default.number,\n  minZoom: _propTypes2.default.number,\n  maxZoom: _propTypes2.default.number,\n  clickTolerance: _propTypes2.default.number,\n  canChangeGroup: _propTypes2.default.bool,\n  canMove: _propTypes2.default.bool,\n  canResize: _propTypes2.default.oneOf([true, false, 'left', 'right', 'both']),\n  useResizeHandle: _propTypes2.default.bool,\n  canSelect: _propTypes2.default.bool,\n  stackItems: _propTypes2.default.bool,\n  traditionalZoom: _propTypes2.default.bool,\n  itemTouchSendsClick: _propTypes2.default.bool,\n  horizontalLineClassNamesForGroup: _propTypes2.default.func,\n  onItemMove: _propTypes2.default.func,\n  onItemResize: _propTypes2.default.func,\n  onItemClick: _propTypes2.default.func,\n  onItemSelect: _propTypes2.default.func,\n  onItemDeselect: _propTypes2.default.func,\n  onCanvasClick: _propTypes2.default.func,\n  onItemDoubleClick: _propTypes2.default.func,\n  onItemContextMenu: _propTypes2.default.func,\n  onCanvasDoubleClick: _propTypes2.default.func,\n  onCanvasContextMenu: _propTypes2.default.func,\n  onZoom: _propTypes2.default.func,\n  moveResizeValidator: _propTypes2.default.func,\n  itemRenderer: _propTypes2.default.func,\n  groupRenderer: _propTypes2.default.func,\n  style: _propTypes2.default.object,\n  keys: _propTypes2.default.shape({\n    groupIdKey: _propTypes2.default.string,\n    groupTitleKey: _propTypes2.default.string,\n    groupLabelKey: _propTypes2.default.string,\n    groupRightTitleKey: _propTypes2.default.string,\n    itemIdKey: _propTypes2.default.string,\n    itemTitleKey: _propTypes2.default.string,\n    itemDivTitleKey: _propTypes2.default.string,\n    itemGroupKey: _propTypes2.default.string,\n    itemTimeStartKey: _propTypes2.default.string,\n    itemTimeEndKey: _propTypes2.default.string\n  }),\n  headerRef: _propTypes2.default.func,\n  scrollRef: _propTypes2.default.func,\n  timeSteps: _propTypes2.default.shape({\n    second: _propTypes2.default.number,\n    minute: _propTypes2.default.number,\n    hour: _propTypes2.default.number,\n    day: _propTypes2.default.number,\n    month: _propTypes2.default.number,\n    year: _propTypes2.default.number\n  }),\n  defaultTimeStart: _propTypes2.default.object,\n  defaultTimeEnd: _propTypes2.default.object,\n  visibleTimeStart: _propTypes2.default.number,\n  visibleTimeEnd: _propTypes2.default.number,\n  onTimeChange: _propTypes2.default.func,\n  onBoundsChange: _propTypes2.default.func,\n  selected: _propTypes2.default.array,\n  headerLabelFormats: _propTypes2.default.shape({\n    yearShort: _propTypes2.default.string,\n    yearLong: _propTypes2.default.string,\n    monthShort: _propTypes2.default.string,\n    monthMedium: _propTypes2.default.string,\n    monthMediumLong: _propTypes2.default.string,\n    monthLong: _propTypes2.default.string,\n    dayShort: _propTypes2.default.string,\n    dayLong: _propTypes2.default.string,\n    hourShort: _propTypes2.default.string,\n    hourMedium: _propTypes2.default.string,\n    hourMediumLong: _propTypes2.default.string,\n    hourLong: _propTypes2.default.string\n  }),\n  subHeaderLabelFormats: _propTypes2.default.shape({\n    yearShort: _propTypes2.default.string,\n    yearLong: _propTypes2.default.string,\n    monthShort: _propTypes2.default.string,\n    monthMedium: _propTypes2.default.string,\n    monthLong: _propTypes2.default.string,\n    dayShort: _propTypes2.default.string,\n    dayMedium: _propTypes2.default.string,\n    dayMediumLong: _propTypes2.default.string,\n    dayLong: _propTypes2.default.string,\n    hourShort: _propTypes2.default.string,\n    hourLong: _propTypes2.default.string,\n    minuteShort: _propTypes2.default.string,\n    minuteLong: _propTypes2.default.string\n  }),\n  resizeDetector: _propTypes2.default.shape({\n    addListener: _propTypes2.default.func,\n    removeListener: _propTypes2.default.func\n  }),\n  verticalLineClassNamesForTime: _propTypes2.default.func,\n  children: _propTypes2.default.node\n};\nReactCalendarTimeline.defaultProps = {\n  sidebarWidth: 150,\n  rightSidebarWidth: 0,\n  dragSnap: 1000 * 60 * 15,\n  // 15min\n  minResizeWidth: 20,\n  stickyHeader: true,\n  lineHeight: 30,\n  itemHeightRatio: 0.65,\n  minZoom: 60 * 60 * 1000,\n  // 1 hour\n  maxZoom: 5 * 365.24 * 86400 * 1000,\n  // 5 years\n  clickTolerance: 3,\n  // how many pixels can we drag for it to be still considered a click?\n  canChangeGroup: true,\n  canMove: true,\n  canResize: 'right',\n  useResizeHandle: false,\n  canSelect: true,\n  stackItems: false,\n  traditionalZoom: false,\n  horizontalLineClassNamesForGroup: null,\n  onItemMove: null,\n  onItemResize: null,\n  onItemClick: null,\n  onItemSelect: null,\n  onItemDeselect: null,\n  onCanvasClick: null,\n  onItemDoubleClick: null,\n  onItemContextMenu: null,\n  onZoom: null,\n  verticalLineClassNamesForTime: null,\n  moveResizeValidator: null,\n  dayBackground: null,\n  defaultTimeStart: null,\n  defaultTimeEnd: null,\n  itemTouchSendsClick: false,\n  style: {},\n  keys: _defaultConfig.defaultKeys,\n  timeSteps: _defaultConfig.defaultTimeSteps,\n  headerRef: function headerRef() {},\n  scrollRef: function scrollRef() {},\n  // if you pass in visibleTimeStart and visibleTimeEnd, you must also pass onTimeChange(visibleTimeStart, visibleTimeEnd),\n  // which needs to update the props visibleTimeStart and visibleTimeEnd to the ones passed\n  visibleTimeStart: null,\n  visibleTimeEnd: null,\n  onTimeChange: function onTimeChange(visibleTimeStart, visibleTimeEnd, updateScrollCanvas) {\n    updateScrollCanvas(visibleTimeStart, visibleTimeEnd);\n  },\n  // called when the canvas area of the calendar changes\n  onBoundsChange: null,\n  children: null,\n  headerLabelFormats: _defaultConfig.defaultHeaderLabelFormats,\n  subHeaderLabelFormats: _defaultConfig.defaultSubHeaderLabelFormats,\n  selected: null\n};\nReactCalendarTimeline.childContextTypes = {\n  getTimelineContext: _propTypes2.default.func\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this.getTimelineContext = function () {\n    var _state3 = _this4.state,\n        width = _state3.width,\n        visibleTimeStart = _state3.visibleTimeStart,\n        visibleTimeEnd = _state3.visibleTimeEnd,\n        canvasTimeStart = _state3.canvasTimeStart,\n        canvasTimeEnd = _state3.canvasTimeEnd;\n    return {\n      timelineWidth: width,\n      visibleTimeStart: visibleTimeStart,\n      visibleTimeEnd: visibleTimeEnd,\n      canvasTimeStart: canvasTimeStart,\n      canvasTimeEnd: canvasTimeEnd\n    };\n  };\n\n  this.resize = function () {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props;\n\n    var _container$getBoundin = _this4.container.getBoundingClientRect(),\n        containerWidth = _container$getBoundin.width;\n\n    var width = containerWidth - props.sidebarWidth - props.rightSidebarWidth;\n    var canvasWidth = (0, _calendar.getCanvasWidth)(width);\n\n    var _stackTimelineItems2 = (0, _calendar.stackTimelineItems)(props.items, props.groups, canvasWidth, _this4.state.canvasTimeStart, _this4.state.canvasTimeEnd, props.keys, props.lineHeight, props.itemHeightRatio, props.stackItems, _this4.state.draggingItem, _this4.state.resizingItem, _this4.state.dragTime, _this4.state.resizingEdge, _this4.state.resizeTime, _this4.state.newGroupOrder),\n        dimensionItems = _stackTimelineItems2.dimensionItems,\n        height = _stackTimelineItems2.height,\n        groupHeights = _stackTimelineItems2.groupHeights,\n        groupTops = _stackTimelineItems2.groupTops; // this is needed by dragItem since it uses pageY from the drag events\n    // if this was in the context of the scrollElement, this would not be necessary\n\n\n    _this4.setState({\n      width: width,\n      dimensionItems: dimensionItems,\n      height: height,\n      groupHeights: groupHeights,\n      groupTops: groupTops\n    });\n\n    _this4.scrollComponent.scrollLeft = width;\n    _this4.scrollHeaderRef.scrollLeft = width;\n  };\n\n  this.onScroll = function (scrollX) {\n    var width = _this4.state.width;\n    var newScrollX = scrollX; // move the virtual canvas if needed\n    // if scrollX is less...i dont know how to explain the logic here\n\n    if (newScrollX < width * 0.5) {\n      newScrollX += width;\n    }\n\n    if (newScrollX > width * 1.5) {\n      newScrollX -= width;\n    }\n\n    _this4.scrollHeaderRef.scrollLeft = newScrollX;\n    _this4.scrollComponent.scrollLeft = newScrollX;\n    var canvasTimeStart = _this4.state.canvasTimeStart;\n    var zoom = _this4.state.visibleTimeEnd - _this4.state.visibleTimeStart;\n    var visibleTimeStart = canvasTimeStart + zoom * scrollX / width;\n\n    if (_this4.state.visibleTimeStart !== visibleTimeStart || _this4.state.visibleTimeEnd !== visibleTimeStart + zoom) {\n      _this4.props.onTimeChange(visibleTimeStart, visibleTimeStart + zoom, _this4.updateScrollCanvas);\n    }\n  };\n\n  this.updateScrollCanvas = function (visibleTimeStart, visibleTimeEnd, forceUpdateDimensions) {\n    var items = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _this4.props.items;\n    var groups = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _this4.props.groups;\n\n    _this4.setState((0, _calendar.calculateScrollCanvas)(visibleTimeStart, visibleTimeEnd, forceUpdateDimensions, items, groups, _this4.props, _this4.state));\n  };\n\n  this.handleWheelZoom = function (speed, xPosition, deltaY) {\n    _this4.changeZoom(1.0 + speed * deltaY / 500, xPosition / _this4.state.width);\n  };\n\n  this.changeZoom = function (scale) {\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n    var _props2 = _this4.props,\n        minZoom = _props2.minZoom,\n        maxZoom = _props2.maxZoom;\n    var oldZoom = _this4.state.visibleTimeEnd - _this4.state.visibleTimeStart;\n    var newZoom = Math.min(Math.max(Math.round(oldZoom * scale), minZoom), maxZoom); // min 1 min, max 20 years\n\n    var newVisibleTimeStart = Math.round(_this4.state.visibleTimeStart + (oldZoom - newZoom) * offset);\n\n    _this4.props.onTimeChange(newVisibleTimeStart, newVisibleTimeStart + newZoom, _this4.updateScrollCanvas);\n  };\n\n  this.showPeriod = function (from, to) {\n    var visibleTimeStart = from.valueOf();\n    var visibleTimeEnd = to.valueOf();\n    var zoom = visibleTimeEnd - visibleTimeStart; // can't zoom in more than to show one hour\n\n    if (zoom < 360000) {\n      return;\n    }\n\n    _this4.props.onTimeChange(visibleTimeStart, visibleTimeStart + zoom, _this4.updateScrollCanvas);\n  };\n\n  this.selectItem = function (item, clickType, e) {\n    if (_this4.state.selectedItem === item || _this4.props.itemTouchSendsClick && clickType === 'touch') {\n      if (item && _this4.props.onItemClick) {\n        var time = _this4.timeFromItemEvent(e);\n\n        _this4.props.onItemClick(item, e, time);\n      }\n    } else {\n      _this4.setState({\n        selectedItem: item\n      });\n\n      if (item && _this4.props.onItemSelect) {\n        var _time = _this4.timeFromItemEvent(e);\n\n        _this4.props.onItemSelect(item, e, _time);\n      } else if (item === null && _this4.props.onItemDeselect) {\n        _this4.props.onItemDeselect(e); // this isnt in the docs. Is this function even used?\n\n      }\n    }\n  };\n\n  this.doubleClickItem = function (item, e) {\n    if (_this4.props.onItemDoubleClick) {\n      var time = _this4.timeFromItemEvent(e);\n\n      _this4.props.onItemDoubleClick(item, e, time);\n    }\n  };\n\n  this.contextMenuClickItem = function (item, e) {\n    if (_this4.props.onItemContextMenu) {\n      var time = _this4.timeFromItemEvent(e);\n\n      _this4.props.onItemContextMenu(item, e, time);\n    }\n  };\n\n  this.getTimeFromRowClickEvent = function (e) {\n    var dragSnap = _this4.props.dragSnap;\n    var _state4 = _this4.state,\n        width = _state4.width,\n        canvasTimeStart = _state4.canvasTimeStart,\n        canvasTimeEnd = _state4.canvasTimeEnd; // this gives us distance from left of row element, so event is in\n    // context of the row element, not client or page\n\n    var offsetX = e.nativeEvent.offsetX;\n    var time = (0, _calendar.calculateTimeForXPosition)(canvasTimeStart, canvasTimeEnd, (0, _calendar.getCanvasWidth)(width), offsetX);\n    time = Math.floor(time / dragSnap) * dragSnap;\n    return time;\n  };\n\n  this.timeFromItemEvent = function (e) {\n    var _state5 = _this4.state,\n        width = _state5.width,\n        visibleTimeStart = _state5.visibleTimeStart,\n        visibleTimeEnd = _state5.visibleTimeEnd;\n    var dragSnap = _this4.props.dragSnap;\n    var scrollComponent = _this4.scrollComponent;\n\n    var _scrollComponent$getB = scrollComponent.getBoundingClientRect(),\n        scrollX = _scrollComponent$getB.left;\n\n    var xRelativeToTimeline = e.clientX - scrollX;\n    var relativeItemPosition = xRelativeToTimeline / width;\n    var zoom = visibleTimeEnd - visibleTimeStart;\n    var timeOffset = relativeItemPosition * zoom;\n    var time = Math.round(visibleTimeStart + timeOffset);\n    time = Math.floor(time / dragSnap) * dragSnap;\n    return time;\n  };\n\n  this.dragItem = function (item, dragTime, newGroupOrder) {\n    var newGroup = _this4.props.groups[newGroupOrder];\n    var keys = _this4.props.keys;\n\n    _this4.setState({\n      draggingItem: item,\n      dragTime: dragTime,\n      newGroupOrder: newGroupOrder,\n      dragGroupTitle: newGroup ? (0, _generic._get)(newGroup, keys.groupLabelKey) : ''\n    });\n  };\n\n  this.dropItem = function (item, dragTime, newGroupOrder) {\n    _this4.setState({\n      draggingItem: null,\n      dragTime: null,\n      dragGroupTitle: null\n    });\n\n    if (_this4.props.onItemMove) {\n      _this4.props.onItemMove(item, dragTime, newGroupOrder);\n    }\n  };\n\n  this.resizingItem = function (item, resizeTime, edge) {\n    _this4.setState({\n      resizingItem: item,\n      resizingEdge: edge,\n      resizeTime: resizeTime\n    });\n  };\n\n  this.resizedItem = function (item, resizeTime, edge, timeDelta) {\n    _this4.setState({\n      resizingItem: null,\n      resizingEdge: null,\n      resizeTime: null\n    });\n\n    if (_this4.props.onItemResize && timeDelta !== 0) {\n      _this4.props.onItemResize(item, resizeTime, edge);\n    }\n  };\n\n  this.handleRowClick = function (e, rowIndex) {\n    // shouldnt this be handled by the user, as far as when to deselect an item?\n    if (_this4.state.selectedItem) {\n      _this4.selectItem(null);\n    }\n\n    if (_this4.props.onCanvasClick == null) return;\n\n    var time = _this4.getTimeFromRowClickEvent(e);\n\n    var groupId = (0, _generic._get)(_this4.props.groups[rowIndex], _this4.props.keys.groupIdKey);\n\n    _this4.props.onCanvasClick(groupId, time, e);\n  };\n\n  this.handleRowDoubleClick = function (e, rowIndex) {\n    if (_this4.props.onCanvasDoubleClick == null) return;\n\n    var time = _this4.getTimeFromRowClickEvent(e);\n\n    var groupId = (0, _generic._get)(_this4.props.groups[rowIndex], _this4.props.keys.groupIdKey);\n\n    _this4.props.onCanvasDoubleClick(groupId, time, e);\n  };\n\n  this.handleScrollContextMenu = function (e, rowIndex) {\n    if (_this4.props.onCanvasContextMenu == null) return;\n\n    var timePosition = _this4.getTimeFromRowClickEvent(e);\n\n    var groupId = (0, _generic._get)(_this4.props.groups[rowIndex], _this4.props.keys.groupIdKey);\n\n    if (_this4.props.onCanvasContextMenu) {\n      e.preventDefault();\n\n      _this4.props.onCanvasContextMenu(groupId, timePosition, e);\n    }\n  };\n\n  this.handleHeaderRef = function (el) {\n    _this4.scrollHeaderRef = el;\n\n    _this4.props.headerRef(el);\n  };\n\n  this.renderHeaders = function () {\n    if (_this4.props.children) {\n      var headerRenderer = void 0;\n\n      _react2.default.Children.map(_this4.props.children, function (child) {\n        if (child.type === _TimelineHeaders2.default) {\n          headerRenderer = child;\n        }\n      });\n\n      if (headerRenderer) {\n        return headerRenderer;\n      }\n    }\n\n    return _react2.default.createElement(_TimelineHeaders2.default, null, _react2.default.createElement(_DateHeader2.default, {\n      unit: 'primaryHeader'\n    }), _react2.default.createElement(_DateHeader2.default, null));\n  };\n\n  this.getScrollElementRef = function (el) {\n    _this4.props.scrollRef(el);\n\n    _this4.scrollComponent = el;\n  };\n};\n\nexports.default = ReactCalendarTimeline;","map":null,"metadata":{},"sourceType":"script"}